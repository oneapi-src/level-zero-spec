
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Core Programming Guide &#8212; Level Zero Specification  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'core/PROG';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Tools Programming Guide" href="../tools/PROG.html" />
    <link rel="prev" title="Introduction" href="INTRO.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Level Zero Specification  documentation</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="INTRO.html">Introduction</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Core Programming Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/PROG.html">Tools Programming Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sysman/PROG.html">Sysman Programming Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="SPIRV.html">SPIR-V Programming Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="EXT.html">Extensions</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../api.html">API Documentation</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="api.html">Core API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tools/api.html">Tools API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sysman/api.html">Sysman API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../versions.html">Versions</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/core/PROG.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Core Programming Guide</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#drivers-and-devices">Drivers and Devices</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#drivers">Drivers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#device">Device</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#initialization-and-discovery">Initialization and Discovery</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#contexts">Contexts</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#memory-and-images">Memory and Images</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#memory">Memory</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#types">Types</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#access-capabilities">Access Capabilities</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#cache-hints-prefetch-and-memory-advice">Cache Hints, Prefetch, and Memory Advice</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reserved-device-allocations">Reserved Device Allocations</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#reserving-virtual-address-space">Reserving Virtual Address Space</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#growing-virtual-address-reservations">Growing Virtual Address Reservations</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#physical-memory">Physical Memory</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mapping-virtual-memory-pages">Mapping Virtual Memory Pages</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#access-attributes">Access Attributes</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#sparse-mappings">Sparse Mappings</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#images">Images</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#device-cache-settings">Device Cache Settings</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#external-memory-import-and-export">External Memory Import and Export</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#command-queues-and-command-lists">Command Queues and Command Lists</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#command-queue-groups">Command Queue Groups</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#discovery">Discovery</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#command-queues">Command Queues</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#creation">Creation</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#execution">Execution</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#destruction">Destruction</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#command-lists">Command Lists</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#creation-1">Creation</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#appending">Appending</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#submission">Submission</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#recycling">Recycling</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#low-latency-immediate-command-lists">Low-Latency Immediate Command Lists</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#synchronization-primitives">Synchronization Primitives</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fences">Fences</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#events">Events</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#kernel-timestamp-events">Kernel Timestamp Events</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#barriers">Barriers</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#execution-barriers">Execution Barriers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#memory-barriers">Memory Barriers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#range-based-memory-barriers">Range-based Memory Barriers</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#modules-and-kernels">Modules and Kernels</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#modules">Modules</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#module-build-options">Module Build Options</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#module-specialization-constants">Module Specialization Constants</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#module-build-log">Module Build Log</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamically-linked-modules">Dynamically Linked Modules</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#module-caching-with-native-binaries">Module Caching with Native Binaries</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#built-in-kernels">Built-in Kernels</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kernels">Kernels</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#kernel-properties">Kernel Properties</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#execution-1">Execution</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#kernel-group-size">Kernel Group Size</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#kernel-arguments">Kernel Arguments</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#kernel-launch">Kernel Launch</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#cooperative-kernels">Cooperative Kernels</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sampler">Sampler</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#formatted-output">Formatted Output</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#advanced">Advanced</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#environment-variables">Environment Variables</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#device-hierarchy">Device Hierarchy</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#affinity-mask">Affinity Mask</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sub-device-support">Sub-Device Support</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#device-residency">Device Residency</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#interoperability-with-other-apis">Interoperability with Other APIs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#inter-process-communication">Inter-Process Communication</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#memory-1">Memory</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#events-1">Events</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#peer-to-peer-access-and-queries">Peer-to-Peer Access and Queries</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="core-programming-guide">
<span id="id1"></span><h1>Core Programming Guide<a class="headerlink" href="#core-programming-guide" title="Link to this heading">#</a></h1>
<section id="drivers-and-devices">
<h2>Drivers and Devices<a class="headerlink" href="#drivers-and-devices" title="Link to this heading">#</a></h2>
<p>The API architecture exposes both physical and logical abstraction of the underlying devices capabilities.
The device, sub-device and memory are exposed at physical level while command queues, events and
synchronization methods are defined as logical entities.
All logical entities will be bound to device level physical capabilities.</p>
<p>Device discovery APIs enumerate the accelerators functional features.
These APIs provide interface to query information like compute unit count within the device or sub device,
available memory and affinity to the compute, user managed cache size and work submission command queues.</p>
<section id="drivers">
<h3>Drivers<a class="headerlink" href="#drivers" title="Link to this heading">#</a></h3>
<p>A driver object represents a collection of physical devices in the system accessed by the same Level-Zero driver.</p>
<ul class="simple">
<li><p>The application may query the number of Level-Zero drivers installed on the system, and their respective handles, using zeInitDrivers, NOTE zeDriverGet is deprecated as of v1.10 of the L0 Spec.</p></li>
<li><p>zeInitDrivers replaces both zeInit and zeDriverGet as of v1.10 of the L0 Spec to both initialize the driver and query the number of drivers.</p></li>
<li><p>Usage of zeInitDrivers and zeDriverGet is mutually exclusive and should not be used together. Usage of them together will result in undefined behavior.</p></li>
<li><p>More than one driver may be available in the system. For example, one driver may support two GPUs from one vendor, another driver supports a GPU from a different vendor, and finally a different driver may support an NPU.</p></li>
<li><p>Driver objects are read-only, global constructs. i.e. Multiple calls to zeInitDrivers with the same flags will return identical driver handles.</p></li>
<li><p>A driver handle is primarily used during device discovery and during creation and management of contexts.</p></li>
</ul>
</section>
<section id="device">
<h3>Device<a class="headerlink" href="#device" title="Link to this heading">#</a></h3>
<p>A device object represents a physical device in the system that supports Level-Zero.</p>
<ul class="simple">
<li><p>The application may query the number devices supported by a driver, and their respective handles, using <a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a>.</p></li>
<li><p>Device objects are read-only, global constructs. i.e. Multiple calls to <a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a> will return identical device handles.</p></li>
<li><p>A device handle is primarily used during creation and management of resources that are specific to a device.</p></li>
<li><p>The application is responsible for sharing memory and explicit submission and synchronization across multiple devices.</p></li>
<li><p>Device may expose sub-devices that allow finer-grained control of physical or logical partitions of a device.</p></li>
</ul>
<p>The following diagram illustrates the relationship between the driver, device and other objects described in this document.</p>
<img alt="../_images/core_device.png" src="../_images/core_device.png" />
<p>Level Zero device model hierarchy is composed of <strong>Root Devices</strong> and <strong>Sub-Devices</strong>: A root-device may contain two or more sub-devices and a sub-device shall belong to a single root-device.
A root-device may not contain a single sub-device, as that would be the same root-device. A root device may also be a device with no sub-devices.</p>
<p>Sub-devices belonging to a root-device may be queried using <a class="reference internal" href="api.html#zedevicegetsubdevices"><span class="std std-ref">zeDeviceGetSubDevices</span></a>. The root-device of a sub-device may be queried using <a class="reference internal" href="api.html#zedevicegetrootdevice"><span class="std std-ref">zeDeviceGetRootDevice</span></a>.
The definition of what a root-device and a sub-device is for a specific device is implementation specific.</p>
</section>
<section id="initialization-and-discovery">
<h3>Initialization and Discovery<a class="headerlink" href="#initialization-and-discovery" title="Link to this heading">#</a></h3>
<p>The Level-Zero API must be initialized by calling zeInitDrivers before calling any other API function. NOTE: zeInit is deprecated as of v1.10 of the L0 Spec.
These functions will load all Level-Zero driver(s) in the system into memory for the current process, for use by all Host threads.
Simultaneous calls to zeInitDrivers are thread-safe and only one instance of each driver will be loaded.</p>
<p>The following pseudo-code demonstrates a basic initialization and device discovery sequence for Core Drivers:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Discover all the driver instances</span>
<span class="n">ze_init_driver_type_desc_t</span><span class="w"> </span><span class="n">desc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">ZE_STRUCTURE_TYPE_INIT_DRIVER_TYPE_DESC</span><span class="p">};</span>
<span class="n">desc</span><span class="p">.</span><span class="n">pNext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">desc</span><span class="p">.</span><span class="n">driverType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UINT32_MAX</span><span class="p">;</span><span class="w"> </span><span class="c1">// all driver types requested</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="n">driverCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">ze_result_t</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zeInitDrivers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driverCount</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"> </span><span class="c1">// Query the number of drivers</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ZE_RESULT_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"> </span><span class="c1">// no drivers found</span>
<span class="p">}</span>

<span class="n">ze_driver_handle_t</span><span class="o">*</span><span class="w"> </span><span class="n">allDrivers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocate</span><span class="p">(</span><span class="n">driverCount</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ze_driver_handle_t</span><span class="p">));</span>
<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zeInitDrivers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driverCount</span><span class="p">,</span><span class="w"> </span><span class="n">allDrivers</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc</span><span class="p">);</span><span class="w"> </span><span class="c1">// Read the driver handles</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ZE_RESULT_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"> </span><span class="c1">// no driver handles found</span>
<span class="p">}</span>

<span class="c1">// Find a driver Handle that supports a GPU device type</span>
<span class="n">ze_driver_handle_t</span><span class="w"> </span><span class="n">hDriver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="n">ze_device_handle_t</span><span class="w"> </span><span class="n">hDevice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">driverCount</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">deviceCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">zeDeviceGet</span><span class="p">(</span><span class="n">allDrivers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">deviceCount</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>

<span class="w">    </span><span class="n">ze_device_handle_t</span><span class="o">*</span><span class="w"> </span><span class="n">allDevices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocate</span><span class="p">(</span><span class="n">deviceCount</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ze_device_handle_t</span><span class="p">));</span>
<span class="w">    </span><span class="n">zeDeviceGet</span><span class="p">(</span><span class="n">allDrivers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">deviceCount</span><span class="p">,</span><span class="w"> </span><span class="n">allDevices</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">deviceCount</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ze_device_properties_t</span><span class="w"> </span><span class="n">device_properties</span><span class="w"> </span><span class="p">{};</span>
<span class="w">        </span><span class="n">device_properties</span><span class="p">.</span><span class="n">stype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES</span><span class="p">;</span>
<span class="w">        </span><span class="n">zeDeviceGetProperties</span><span class="p">(</span><span class="n">allDevices</span><span class="p">[</span><span class="n">d</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">device_properties</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">ZE_DEVICE_TYPE_GPU</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">device_properties</span><span class="p">.</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">hDriver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allDrivers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">            </span><span class="n">hDevice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allDevices</span><span class="p">[</span><span class="n">d</span><span class="p">];</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">allDevices</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="k">nullptr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">hDriver</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">free</span><span class="p">(</span><span class="n">allDrivers</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="k">nullptr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">hDevice</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w"> </span><span class="c1">// no GPU devices found</span>

<span class="p">...</span>
</pre></div>
</div>
</section>
</section>
<section id="contexts">
<h2>Contexts<a class="headerlink" href="#contexts" title="Link to this heading">#</a></h2>
<p>A context is a logical object used by the driver for managing all memory, command queues/lists, modules, synchronization objects, etc.</p>
<ul class="simple">
<li><p>A context handle is primarily used during creation and management of resources that may be used by multiple devices.</p></li>
<li><p>For example, memory is not implicitly shared across all devices supported by a driver. However, it is available to be explicitly shared.</p></li>
</ul>
<p>The following pseudo-code demonstrates a basic context creation:</p>
<pre class="literal-block">// Create context
<a class="reference internal" href="api.html#ze-context-desc-t"><span class="std std-ref">ze_context_desc_t</span></a> ctxtDesc = {
   <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_CONTEXT_DESC</span></a>,
   nullptr,
   0
};
<a class="reference internal" href="api.html#zecontextcreate"><span class="std std-ref">zeContextCreate</span></a>(hDriver, &amp;ctxtDesc, &amp;hContext);</pre>
<p>An application may optionally create multiple contexts using <a class="reference internal" href="api.html#zecontextcreate"><span class="std std-ref">zeContextCreate</span></a>.</p>
<ul class="simple">
<li><p>The primary usage-model for multiple contexts is isolation of memory and objects for multiple libraries within the same process.</p></li>
<li><p>The same context may be used simultaneously on multiple Host threads.</p></li>
</ul>
<p>The following pseudo-code demonstrates a basic context creation and activation sequence:</p>
<pre class="literal-block">// Create context(s)
<a class="reference internal" href="api.html#zecontextcreate"><span class="std std-ref">zeContextCreate</span></a>(hDriver, &amp;ctxtDesc, &amp;hContextA);
<a class="reference internal" href="api.html#zecontextcreate"><span class="std std-ref">zeContextCreate</span></a>(hDriver, &amp;ctxtDesc, &amp;hContextB);

<a class="reference internal" href="api.html#zememallochost"><span class="std std-ref">zeMemAllocHost</span></a>(hContextA, &amp;desc, 80, 0, &amp;ptrA);
<a class="reference internal" href="api.html#zememallochost"><span class="std std-ref">zeMemAllocHost</span></a>(hContextB, &amp;desc, 88, 0, &amp;ptrB);

memcpy(ptrA, ptrB, 0xe); // ok
<a class="reference internal" href="api.html#zememgetallocproperties"><span class="std std-ref">zeMemGetAllocProperties</span></a>(hContextA, ptrB, &amp;props, &amp;hDevice); // illegal: Context A has no knowledge of ptrB</pre>
<p>If a device was hung or reset, then the context is no longer valid and all APIs will return <a class="reference internal" href="api.html#ze-result-t"><span class="std std-ref">ZE_RESULT_ERROR_DEVICE_LOST</span></a> when any object associated with that context is used.
All pointers to memory allocations and handles to objects (including other contexts) created on the context will be invalid and should no longer be used.
An application can use <a class="reference internal" href="api.html#zecontextgetstatus"><span class="std std-ref">zeContextGetStatus</span></a> at any time to check the status of a context.</p>
<p>In order to recover, the context must be destroyed using <a class="reference internal" href="api.html#zecontextdestroy"><span class="std std-ref">zeContextDestroy</span></a>.
After the device is reset, the application can create a new context and continue operation.
An application must call <a class="reference internal" href="api.html#zedevicegetstatus"><span class="std std-ref">zeDeviceGetStatus</span></a> to confirm the device has been reset and update the OS handle attached to the device handle.
Otherwise, even after the device has been reset, the call to <a class="reference internal" href="api.html#zecontextcreate"><span class="std std-ref">zeContextCreate</span></a> will fail.</p>
</section>
<section id="memory-and-images">
<h2>Memory and Images<a class="headerlink" href="#memory-and-images" title="Link to this heading">#</a></h2>
<p>Memory is visible to the upper-level software stack as unified memory with a single virtual address space
covering both the Host and a specific device.</p>
<p>For GPUs, the API exposes two levels of the device memory hierarchy:</p>
<ol class="arabic">
<li><p>Local Device Memory: can be managed at the device and/or sub device level.</p></li>
<li><p>Device Cache(s):</p>
<blockquote>
<div><ul class="simple">
<li><p>Last Level Cache (L3) can be controlled through memory allocation APIs.</p></li>
<li><p>Low Level Cache (L1) can be controlled through program language intrinsics.</p></li>
</ul>
</div></blockquote>
</li>
</ol>
<p>The API allows allocation of buffers and images at device and sub device granularity with full cacheablity hints.</p>
<ul class="simple">
<li><p>Buffers are transparent memory accessed through virtual address pointers</p></li>
<li><p>Images are opaque objects accessed through handles</p></li>
</ul>
<p>The memory APIs provide allocation methods to allocate either device, host or shared memory.
The APIs enable both implicit and explicit management of the resources by the application or runtimes.
The interface also provides query capabilities for all memory objects.</p>
<p>There are two types of allocations:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#linearmemory"><span class="std std-ref">Memory</span></a> - linear, unformatted allocations for direct access from both the host and device.</p></li>
<li><p><a class="reference internal" href="#images"><span class="std std-ref">Images</span></a> - non-linear, formatted allocations for direct access from the device.</p></li>
</ol>
<section id="memory">
<span id="linearmemory"></span><h3>Memory<a class="headerlink" href="#memory" title="Link to this heading">#</a></h3>
<p>Linear, unformatted memory allocations are represented as pointers in the host application.
A pointer on the Host has the same size as a pointer on the device.</p>
<section id="types">
<h4>Types<a class="headerlink" href="#types" title="Link to this heading">#</a></h4>
<p>Three types of allocations are supported.
The type of allocation describes the <em>ownership</em> of the allocation:</p>
<ol class="arabic">
<li><p><strong>Host</strong> allocations are owned by the host and are intended to be allocated out of system memory.</p>
<blockquote>
<div><ul class="simple">
<li><p>Host allocations are accessible by the host and one or more devices.</p></li>
<li><p>The same pointer to a host allocation may be used on the host and all supported devices; they have <em>address equivalence</em>.</p></li>
<li><p>Host allocations are not expected to migrate between system memory and device local memory.</p></li>
<li><p>Host allocations trade off wide accessibility and transfer benefits for potentially higher per-access costs, such as over PCI express.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>Device</strong> allocations are owned by a specific device and are intended to be allocated out of device local memory, if present.</p>
<blockquote>
<div><ul class="simple">
<li><p>Device allocations generally trade off access limitations for higher performance.</p></li>
<li><p>With very few exceptions, device allocations may only be accessed by the specific device that they are allocated on,
or copied to another device or Host allocation.</p></li>
<li><p>The same pointer to a device allocation may be used on any supported device.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>Shared</strong> allocations share ownership and are intended to migrate between the host and one or more devices.</p>
<blockquote>
<div><ul class="simple">
<li><p>Shared allocations are accessible by at least the host and an associated device.</p></li>
<li><p>Shared allocations may be accessed by other devices in some cases.</p></li>
<li><p>Shared allocations trade off transfer costs for per-access benefits.</p></li>
<li><p>The same pointer to a shared allocation may be used on the host and all supported devices.</p></li>
</ul>
</div></blockquote>
</li>
</ol>
<p>A <strong>Shared System</strong> allocation is a sub-class of a <strong>Shared</strong> allocation,
where the memory is allocated by a <em>system allocator</em> (such as <code class="docutils literal notranslate"><span class="pre">malloc</span></code> or <code class="docutils literal notranslate"><span class="pre">new</span></code>) rather than by an allocation API.
Shared system allocations have no associated device; they are inherently cross-device.
Like other shared allocations, shared system allocations are intended to migrate between the host and supported devices,
and the same pointer to a shared system allocation may be used on the host and all supported devices.</p>
<p>In summary:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Initial Location</p></th>
<th class="head"><p>Accessible By</p></th>
<th class="head"></th>
<th class="head"><p>Migratable To</p></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td rowspan="2"><p><strong>Host</strong></p></td>
<td rowspan="2"><p>Host</p></td>
<td><p>Host</p></td>
<td><p>Yes</p></td>
<td><p>Host</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-odd"><td><p>Any Device</p></td>
<td><p>Yes (perhaps over PCIe)</p></td>
<td><p>Device</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td rowspan="3"><p><strong>Device</strong></p></td>
<td rowspan="3"><p>Specific Device</p></td>
<td><p>Host</p></td>
<td><p>No</p></td>
<td><p>Host</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>Specific Device</p></td>
<td><p>Yes</p></td>
<td><p>Device</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-even"><td><p>Another Device</p></td>
<td><p>Optional (may require p2p)</p></td>
<td><p>Another Device</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td rowspan="3"><p><strong>Shared</strong></p></td>
<td rowspan="3"><p>Host, Specific Device, or Unspecified</p></td>
<td><p>Host</p></td>
<td><p>Yes</p></td>
<td><p>Host</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Specific Device</p></td>
<td><p>Yes</p></td>
<td><p>Device</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Another Device</p></td>
<td><p>Optional (may require p2p)</p></td>
<td><p>Another Device</p></td>
<td><p>Optional</p></td>
</tr>
<tr class="row-even"><td rowspan="2"><p><strong>Shared System</strong></p></td>
<td rowspan="2"><p>Host</p></td>
<td><p>Host</p></td>
<td><p>Yes</p></td>
<td><p>Host</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Device</p></td>
<td><p>Yes</p></td>
<td><p>Device</p></td>
<td><p>Yes</p></td>
</tr>
</tbody>
</table>
<p>At a minimum, drivers will assign unique physical pages for each device and shared memory allocation.
However, it is undefined behavior for an application to access memory outside of the allocation size requested.
The actual page size used for an allocation can be queried from <a class="reference internal" href="api.html#ze-memory-allocation-properties-t"><span class="std std-ref">ze_memory_allocation_properties_t</span></a>.pageSize using <a class="reference internal" href="api.html#zememgetallocproperties"><span class="std std-ref">zeMemGetAllocProperties</span></a>.
Applications should implement usage-specific allocators from device memory pools (e.g., small and/or fixed-sized allocations, lock-free, etc.).</p>
<p>Furthermore, drivers may <em>oversubscribe</em> some <strong>shared</strong> allocations.
When and how such oversubscription occurs, including which allocations are evicted when the working set changes, are considered implementation details.</p>
</section>
<section id="access-capabilities">
<h4>Access Capabilities<a class="headerlink" href="#access-capabilities" title="Link to this heading">#</a></h4>
<p>Devices may support different access capabilities for each type of allocation. Supported capabilities are:</p>
<ol class="arabic">
<li><p><strong>Host Allocations</strong>: Assume a buffer allocated on the host via <a class="reference internal" href="api.html#zememallochost"><span class="std std-ref">zeMemAllocHost</span></a> that is accessed from device hDevice:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="api.html#ze-memory-access-cap-flags-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAP_FLAG_RW</span></a>: Buffer can be accessed (read from as well as written to) from hDevice as well as from the host.</p></li>
<li><p><a class="reference internal" href="api.html#ze-memory-access-cap-flags-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAP_FLAG_ATOMIC</span></a>: Buffer can be atomically accessed from hDevice. Atomic operations may include relaxed consistency read-modify-write atomics and atomic operations that enforce memory consistency for non-atomic operations.</p></li>
<li><p><a class="reference internal" href="api.html#ze-memory-access-cap-flags-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAP_FLAG_CONCURRENT</span></a>: Buffer can be accessed from hDevice concurrently with another device that also supports concurrent access as well as with the host itself. Concurrent access is at the granularity of the whole allocation. This capability makes no guarantees about coherency or memory consistency. Undefined behavior occurs if concurrent accesses are made to an allocation from devices that do not support concurrent access. Devices that support concurrent access but do not support concurrent atomic access must write to unique non-overlapping memory locations to avoid data races and hence undefined behavior.</p></li>
<li><p><a class="reference internal" href="api.html#ze-memory-access-cap-flags-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAP_FLAG_CONCURRENT_ATOMIC</span></a>: Buffer can be atomically accessed from hDevice concurrently with another device that also supports concurrent atomic access as well as with the host itself. Concurrent atomic access is at the granularity of the whole allocation. Memory consistency can be enforced between the host &amp; devices that support concurrent atomic access using atomic operations. Undefined behavior occurs if concurrent atomic accesses are made to an allocation from devices that do not support concurrent atomic access.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>Device Allocations</strong>: Assume a buffer allocated on device hDevice via <a class="reference internal" href="api.html#zememallocdevice"><span class="std std-ref">zeMemAllocDevice</span></a>:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="api.html#ze-memory-access-cap-flags-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAP_FLAG_RW</span></a>: Buffer can be accessed (read from as well as written to) from hDevice.</p></li>
<li><p><a class="reference internal" href="api.html#ze-memory-access-cap-flags-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAP_FLAG_ATOMIC</span></a>: Buffer can be atomically accessed from hDevice. Atomic operations may include relaxed consistency read-modify-write atomics and atomic operations that enforce memory consistency for non-atomic operations.</p></li>
<li><p><a class="reference internal" href="api.html#ze-memory-access-cap-flags-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAP_FLAG_CONCURRENT</span></a>: Buffer can be accessed from hDevice concurrently with another device that also supports concurrent access. By symmetry, the buffer could be located on either device and be accessed concurrently from both devices. Concurrent access is at the granularity of the whole allocation. This capability makes no guarantees about coherency or memory consistency. Undefined behavior occurs if concurrent accesses are made to an allocation from devices that do not support concurrent access. Devices that support concurrent access but do not support concurrent atomic access must write to unique non-overlapping memory locations to avoid data races and hence undefined behavior. A device can concurrently access a buffer on another device if both devices support concurrent access and both devices also support peer-to-peer access. If one device does not permit concurrent access, but peer-to-peer access is permitted, then the devices support peer-to-peer access but not concurrently to the same buffer.</p></li>
<li><p><a class="reference internal" href="api.html#ze-memory-access-cap-flags-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAP_FLAG_CONCURRENT_ATOMIC</span></a>: Buffer can be atomically accessed from hDevice concurrently with another device that also supports concurrent atomic access. By symmetry, the buffer could be located on either device and be atomically accessed concurrently from both devices. Concurrent atomic access is at the granularity of the whole allocation. Memory consistency can be enforced between devices that support concurrent atomic access using atomic operations. Undefined behavior occurs if concurrent atomic accesses are made to an allocation from devices that do not support concurrent atomic access. A device can concurrently perform atomic access to a device buffer on another device if both devices support concurrent atomic access and both devices also support peer-to-peer atomic access. If one device does not permit concurrent atomic access, but peer-to-peer atomic access is permitted, then the devices support peer-to-peer atomic access but not concurrently to the same buffer.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>Shared Single Device Allocations</strong>: Assume a shared allocation across the host &amp; device hDevice created via <a class="reference internal" href="api.html#zememallocshared"><span class="std std-ref">zeMemAllocShared</span></a></p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="api.html#ze-memory-access-cap-flags-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAP_FLAG_RW</span></a>: Buffer can be accessed (read from as well as written to) from hDevice as well as from the host.</p></li>
<li><p><a class="reference internal" href="api.html#ze-memory-access-cap-flags-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAP_FLAG_ATOMIC</span></a>: Buffer can be atomically accessed from hDevice as well as from the host. Atomic operations may include relaxed consistency read-modify-write atomics and atomic operations that enforce memory consistency for non-atomic operations.</p></li>
<li><p><a class="reference internal" href="api.html#ze-memory-access-cap-flags-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAP_FLAG_CONCURRENT</span></a>: Buffer can be accessed from hDevice concurrently with the host. Concurrent access is at the granularity of the whole allocation. This capability makes no guarantees about coherency or memory consistency. Undefined behavior occurs if concurrent accesses are made to the allocation from the host and from hDevice if it does not support concurrent access. A devices that supports concurrent access but does not support concurrent atomic access must write to unique non-overlapping (with the host) memory locations to avoid data races and hence undefined behavior.</p></li>
<li><p><a class="reference internal" href="api.html#ze-memory-access-cap-flags-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAP_FLAG_CONCURRENT_ATOMIC</span></a>: Buffer can be atomically accessed from hDevice concurrently with the host. Concurrent atomic access is at the granularity of the whole allocation. Memory consistency can be enforced between devices that support concurrent atomic access using atomic operations. Undefined behavior occurs if concurrent atomic accesses are made to the allocation from the host &amp; hDevice if it does not support concurrent atomic access.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>Shared Cross Device Allocations</strong>: Assume a shared allocation across the host &amp; the set of devices that support cross-device shared access capabilities created via <a class="reference internal" href="api.html#zememallocshared"><span class="std std-ref">zeMemAllocShared</span></a> that is accessed from device hDevice:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="api.html#ze-memory-access-cap-flags-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAP_FLAG_RW</span></a>: Buffer can be accessed (read from as well as written to) from hDevice as well as from the host.</p></li>
<li><p><a class="reference internal" href="api.html#ze-memory-access-cap-flags-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAP_FLAG_ATOMIC</span></a>: Buffer can be atomically accessed from hDevice as well as from the host. Atomic operations may include relaxed consistency read-modify-write atomics and atomic operations that enforce memory consistency for non-atomic operations.</p></li>
<li><p><a class="reference internal" href="api.html#ze-memory-access-cap-flags-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAP_FLAG_CONCURRENT</span></a>: Buffer can be accessed from hDevice concurrently with another device that also supports concurrent access and from the host. Concurrent access is at the granularity of the whole allocation. This capability makes no guarantees about coherency or memory consistency. Undefined behavior occurs if concurrent accesses are made to an allocation from devices that do not support concurrent access. Devices that support concurrent access but do not support concurrent atomic access must write to unique non-overlapping memory locations to avoid data races and hence undefined behavior.</p></li>
<li><p><a class="reference internal" href="api.html#ze-memory-access-cap-flags-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAP_FLAG_CONCURRENT_ATOMIC</span></a>: Buffer can be atomically accessed from hDevice concurrently with another device that also supports concurrent atomic access and from the host. Concurrent atomic access is at the granularity of the whole allocation. Memory consistency can be enforced between devices that support concurrent atomic access using atomic operations. Undefined behavior occurs if concurrent atomic accesses are made to an allocation from devices that do not support concurrent atomic access.</p></li>
</ul>
</div></blockquote>
</li>
</ol>
<p>The required matrix of capabilities are:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Allocation Type</p></th>
<th class="head"><p>RW Access</p></th>
<th class="head"><p>Atomic Access</p></th>
<th class="head"><p>Concurrent Access</p></th>
<th class="head"><p>Concurrent Atomic Access</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Host</strong></p></td>
<td><p>Required</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Device</strong></p></td>
<td><p>Required</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
</tr>
<tr class="row-even"><td><p><strong>Shared</strong></p></td>
<td><p>Required</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Shared</strong> (Cross-Device)</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
</tr>
<tr class="row-even"><td><p><strong>Shared System</strong> (Cross-Device)</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
</tr>
</tbody>
</table>
</section>
<section id="cache-hints-prefetch-and-memory-advice">
<h4>Cache Hints, Prefetch, and Memory Advice<a class="headerlink" href="#cache-hints-prefetch-and-memory-advice" title="Link to this heading">#</a></h4>
<p>Cacheability hints may be provided via separate host and device allocation flags when memory is allocated.</p>
<p><strong>Shared</strong> allocations may be prefetched to a supporting device via the <a class="reference internal" href="api.html#zecommandlistappendmemoryprefetch"><span class="std std-ref">zeCommandListAppendMemoryPrefetch</span></a> API.
Prefetching may allow memory transfers to be scheduled concurrently with other computations and may improve performance.</p>
<p>Additionally, an application may provide memory advice for a <strong>shared</strong> allocation via the <a class="reference internal" href="api.html#zecommandlistappendmemadvise"><span class="std std-ref">zeCommandListAppendMemAdvise</span></a> API,
to override driver heuristics or migration policies.
Memory advice may avoid unnecessary or unprofitable memory transfers and may improve performance.</p>
<p>Both prefetch and memory advice are asynchronous operations that are appended into command lists.</p>
</section>
</section>
<section id="reserved-device-allocations">
<h3>Reserved Device Allocations<a class="headerlink" href="#reserved-device-allocations" title="Link to this heading">#</a></h3>
<p>If an application needs finer grained control of physical memory consumption for device allocations then it
can reserve a range of the virtual address space and map this to physical memory as needed. This provides
flexibility for applications to manage large dynamic data structures which can grow and shrink over time
while maintaining optimal physical memory usage.</p>
<section id="reserving-virtual-address-space">
<h4>Reserving Virtual Address Space<a class="headerlink" href="#reserving-virtual-address-space" title="Link to this heading">#</a></h4>
<p>Virtual memory can be reserved using <a class="reference internal" href="api.html#zevirtualmemreserve"><span class="std std-ref">zeVirtualMemReserve</span></a>. The reservation starting address
and size must be page aligned. Applications should query the page size for the allocation
using <a class="reference internal" href="api.html#zevirtualmemquerypagesize"><span class="std std-ref">zeVirtualMemQueryPageSize</span></a>.</p>
<p>The following pseudo-code demonstrates a basic sequence for reserving virtual memory:</p>
<pre class="literal-block">// Query page size for our 1MB allocation.
size_t pageSize;
size_t allocationSize = 1048576;
<a class="reference internal" href="api.html#zevirtualmemquerypagesize"><span class="std std-ref">zeVirtualMemQueryPageSize</span></a>(hContext, hDevice, allocationSize, &amp;pageSize);

// Reserve 1MB of virtual address space.
size_t reserveSize = align(allocationSize, pageSize);

void* ptr = nullptr;
<a class="reference internal" href="api.html#zevirtualmemreserve"><span class="std std-ref">zeVirtualMemReserve</span></a>(hContext, nullptr, reserveSize, &amp;ptr);</pre>
</section>
<section id="growing-virtual-address-reservations">
<h4>Growing Virtual Address Reservations<a class="headerlink" href="#growing-virtual-address-reservations" title="Link to this heading">#</a></h4>
<p>An application may wish to reserve an address range starting at a specific virtual address.
This may be useful when there is a need to grow a reservation. However, if the
implementation is not able to reserve the new allocation at the requested starting address
then it will find a new suitable range with a different starting address. If the application
requires a specific starting address then the application should ensure that the return
address from <a class="reference internal" href="api.html#zevirtualmemreserve"><span class="std std-ref">zeVirtualMemReserve</span></a> matches the starting address it wants. If they
are different then the application may want to create a new larger reservation and remap
the physical memory from the first reservation to this new reservation and free the
old reservation.</p>
<pre class="literal-block">// Reserve another 1MB of virtual address space that is contiguous with previous reservation.
void* newptr = (uint8_t*)ptr + reserveSize;
void* retptr;
<a class="reference internal" href="api.html#zevirtualmemreserve"><span class="std std-ref">zeVirtualMemReserve</span></a>(hContext, newptr, reserveSize, &amp;retptr);

if (retptr != newptr)
{
    // Free new reservation as it's not what we want due to incorrect starting address.
    <a class="reference internal" href="api.html#zevirtualmemfree"><span class="std std-ref">zeVirtualMemFree</span></a>(hContext, retptr, reserveSize);

    // Make new larger 2MB reservation and remap physical pages to this.
    size_t pageSize;
    size_t largerAllocationSize = 2097152;
    <a class="reference internal" href="api.html#zevirtualmemquerypagesize"><span class="std std-ref">zeVirtualMemQueryPageSize</span></a>(hContext, hDevice, largerAllocationSize, &amp;pageSize);

    // Reserve 2MB of virtual address space.
    size_t largerReserveSize = align(largerAllocationSize, pageSize);

    void* ptr = nullptr;
    <a class="reference internal" href="api.html#zevirtualmemreserve"><span class="std std-ref">zeVirtualMemReserve</span></a>(hContext, nullptr, largerReserveSize, &amp;ptr);

    // Remap physical pages from original reservation to our new larger reservation.
    ...

    // Free original reservation that we were trying to grow.
    <a class="reference internal" href="api.html#zevirtualmemfree"><span class="std std-ref">zeVirtualMemFree</span></a>(hContext, ptr, reserveSize);
}</pre>
</section>
<section id="physical-memory">
<h4>Physical Memory<a class="headerlink" href="#physical-memory" title="Link to this heading">#</a></h4>
<p>Physical memory is explicitly represented in the API as physical memory objects
that are reservations of physical pages. The application will use <a class="reference internal" href="api.html#zephysicalmemcreate"><span class="std std-ref">zePhysicalMemCreate</span></a>
to create a physical memory object.</p>
<p>The following pseudo-code demonstrates a basic sequence for creating a physical memory object:</p>
<pre class="literal-block">// Create 1MB physical memory object
ze_physical_mem_handle_t hPhysicalAlloc;
size_t physicalSize = align(allocationSize, pageSize);
<a class="reference internal" href="api.html#ze-physical-mem-desc-t"><span class="std std-ref">ze_physical_mem_desc_t</span></a> pmemDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_PHYSICAL_MEM_DESC</span></a>,
    nullptr,
    0, // flags
    physicalSize // size
};

<a class="reference internal" href="api.html#zephysicalmemcreate"><span class="std std-ref">zePhysicalMemCreate</span></a>(hContext, hDevice, &amp;pmemDesc, &amp;hPhysicalAlloc);</pre>
</section>
<section id="mapping-virtual-memory-pages">
<h4>Mapping Virtual Memory Pages<a class="headerlink" href="#mapping-virtual-memory-pages" title="Link to this heading">#</a></h4>
<p>Reserved virtual memory pages can be mapped to physical memory using <a class="reference internal" href="api.html#zevirtualmemmap"><span class="std std-ref">zeVirtualMemMap</span></a>.
An application can map the entire reserved virtual address range or can sparsely map the
reserved virtual address range using one or more physical memory objects. Once mapped, the
physical pages for a physical memory object can be faulted in for devices that support
on-demand paging. In addition, the residency API can be used to control residency of
these physical pages.</p>
<p>The following pseudo-code demonstrates mapping a 1MB reservation into physical memory:</p>
<pre class="literal-block">// Map entire 1MB reservation and set access to read/write.
<a class="reference internal" href="api.html#zevirtualmemmap"><span class="std std-ref">zeVirtualMemMap</span></a>(hContext, ptr, reserveSize, hPhysicalAlloc, 0,
    <a class="reference internal" href="api.html#ze-memory-access-attribute-t"><span class="std std-ref">ZE_MEMORY_ACCESS_ATTRIBUTE_READWRITE</span></a>);</pre>
</section>
<section id="access-attributes">
<h4>Access Attributes<a class="headerlink" href="#access-attributes" title="Link to this heading">#</a></h4>
<p>Access attributes can be set for a range of pages when mapping virtual memory
pages with <a class="reference internal" href="api.html#zevirtualmemmap"><span class="std std-ref">zeVirtualMemMap</span></a> or with <a class="reference internal" href="api.html#zevirtualmemsetaccessattribute"><span class="std std-ref">zeVirtualMemSetAccessAttribute</span></a>.
In addition, an application can query access attributes for a page aligned
virtual memory range.</p>
<pre class="literal-block">size_t accessRangeSize;
<a class="reference internal" href="api.html#ze-memory-access-attribute-t"><span class="std std-ref">ze_memory_access_attribute_t</span></a> access;
<a class="reference internal" href="api.html#zevirtualmemgetaccessattribute"><span class="std std-ref">zeVirtualMemGetAccessAttribute</span></a>(hContext, ptr, reserveSize, &amp;access, &amp;accessRangeSize);

// Expecting entire range to have the same access attribute and it be read/write.
assert(accessRangeSize == reserveSize);
assert(access == <a class="reference internal" href="api.html#ze-memory-access-attribute-t"><span class="std std-ref">ZE_MEMORY_ACCESS_ATTRIBUTE_READWRITE</span></a>);</pre>
</section>
<section id="sparse-mappings">
<h4>Sparse Mappings<a class="headerlink" href="#sparse-mappings" title="Link to this heading">#</a></h4>
<p>Applications may desire to reserve large virtual address ranges to make available
to its custom allocators. These ranges can be sparsely mapped using one or more physical
memory objects. It is recommended that the application queries the page size for each
suballocation to ensure the implementation can use an optimal page size for the mappings
based on the alignments used for starting address and size used.</p>
<p>The following example makes a 1GB reserved allocation and then makes both 128KB and 8MB sub-allocations.</p>
<img alt="../_images/core_reserved_suballocations.png" src="../_images/core_reserved_suballocations.png" />
<pre class="literal-block">// Reserve 1GB of virtual address space to manage.
size_t pageSize;
size_t allocationSize = 1048576000;
<a class="reference internal" href="api.html#zevirtualmemquerypagesize"><span class="std std-ref">zeVirtualMemQueryPageSize</span></a>(hContext, hDevice, allocationSize, &amp;pageSize);

size_t reserveSize = align(allocationSize, pageSize);

void* ptr = nullptr;
<a class="reference internal" href="api.html#zevirtualmemreserve"><span class="std std-ref">zeVirtualMemReserve</span></a>(hContext, nullptr, reserveSize, &amp;ptr);

...

// Sub-allocate 128KB of our 1GB allocation.
size_t subAllocSize = 131072;
<a class="reference internal" href="api.html#zevirtualmemquerypagesize"><span class="std std-ref">zeVirtualMemQueryPageSize</span></a>(hContext, hDevice, subAllocSize, &amp;pageSize);

// Create physical memory object for our 128KB sub-allocation.
size_t subAllocAlignedSize = align(subAllocSize, pageSize);
<a class="reference internal" href="api.html#ze-physical-mem-desc-t"><span class="std std-ref">ze_physical_mem_desc_t</span></a> pmemDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_PHYSICAL_MEM_DESC</span></a>,
    nullptr,
    0, // flags
    subAllocAlignedSize // size
};
ze_physical_mem_handle_t hPhysicalAlloc;
<a class="reference internal" href="api.html#zephysicalmemcreate"><span class="std std-ref">zePhysicalMemCreate</span></a>(hContext, hDevice, &amp;pmemDesc, &amp;hPhysicalAlloc);

// Find suitable 128KB sub-allocation that matches page alignments.
...

<a class="reference internal" href="api.html#zevirtualmemmap"><span class="std std-ref">zeVirtualMemMap</span></a>(hContext, subAllocPtr, subAllocAlignedSize, hPhysicalAlloc, 0,
    <a class="reference internal" href="api.html#ze-memory-access-attribute-t"><span class="std std-ref">ZE_MEMORY_ACCESS_ATTRIBUTE_READWRITE</span></a>);

...

// Sub-allocate 8MB of our 1GB allocation.
size_t subAllocDiffSize = 8388608;
<a class="reference internal" href="api.html#zevirtualmemquerypagesize"><span class="std std-ref">zeVirtualMemQueryPageSize</span></a>(hContext, hDevice, subAllocDiffSize, &amp;pageSize);
...</pre>
</section>
</section>
<section id="images">
<span id="id2"></span><h3>Images<a class="headerlink" href="#images" title="Link to this heading">#</a></h3>
<p>An image is used to store multi-dimensional and format-defined memory.
An image’s contents may be stored in an implementation-specific encoding
and layout in memory for optimal device access
(e.g., tile swizzle patterns, lossless compression, etc.).
There is no support for direct Host access to an image’s content.
However, when an image is copied to a Host-accessible memory allocation,
its contents will be implicitly decoded to be implementation-independent.</p>
<pre class="literal-block">// Specify single component FLOAT32 format
<a class="reference internal" href="api.html#ze-image-format-t"><span class="std std-ref">ze_image_format_t</span></a> format = {
    <a class="reference internal" href="api.html#ze-image-format-layout-t"><span class="std std-ref">ZE_IMAGE_FORMAT_LAYOUT_32</span></a>, <a class="reference internal" href="api.html#ze-image-format-type-t"><span class="std std-ref">ZE_IMAGE_FORMAT_TYPE_FLOAT</span></a>,
    <a class="reference internal" href="api.html#ze-image-format-swizzle-t"><span class="std std-ref">ZE_IMAGE_FORMAT_SWIZZLE_R</span></a>, <a class="reference internal" href="api.html#ze-image-format-swizzle-t"><span class="std std-ref">ZE_IMAGE_FORMAT_SWIZZLE_0</span></a>, <a class="reference internal" href="api.html#ze-image-format-swizzle-t"><span class="std std-ref">ZE_IMAGE_FORMAT_SWIZZLE_0</span></a>, <a class="reference internal" href="api.html#ze-image-format-swizzle-t"><span class="std std-ref">ZE_IMAGE_FORMAT_SWIZZLE_1</span></a>
};

<a class="reference internal" href="api.html#ze-image-desc-t"><span class="std std-ref">ze_image_desc_t</span></a> imageDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_IMAGE_DESC</span></a>,
    nullptr,
    0, // read-only
    <a class="reference internal" href="api.html#ze-image-type-t"><span class="std std-ref">ZE_IMAGE_TYPE_2D</span></a>,
    format,
    128, 128, 0, 0, 0
};
ze_image_handle_t hImage;
<a class="reference internal" href="api.html#zeimagecreate"><span class="std std-ref">zeImageCreate</span></a>(hContext, hDevice, &amp;imageDesc, &amp;hImage);

// upload contents from host pointer
<a class="reference internal" href="api.html#zecommandlistappendimagecopyfrommemory"><span class="std std-ref">zeCommandListAppendImageCopyFromMemory</span></a>(hCommandList, hImage, nullptr, pImageData, nullptr, 0, nullptr);
...</pre>
<p>A format descriptor is a combination of a format layout, type, and a swizzle.
The format layout describes the number of components and their corresponding bit
widths. The type describes the data type for all of these components with some
exceptions that are described below. The swizzles associate how the image
components are mapped into XYZW/RGBA channels of the kernel. It is allowed
to replicate components into the channels.</p>
<p>The following table describes which types are required for each layout.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Format layout</p></th>
<th class="head"><p>UINT</p></th>
<th class="head"><p>SINT</p></th>
<th class="head"><p>UNORM</p></th>
<th class="head"><p>SNORM</p></th>
<th class="head"><p>FLOAT</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>8</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Unsupported</p></td>
</tr>
<tr class="row-odd"><td><p>8_8</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Unsupported</p></td>
</tr>
<tr class="row-even"><td><p>8_8_8_8</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Unsupported</p></td>
</tr>
<tr class="row-odd"><td><p>16</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
</tr>
<tr class="row-even"><td><p>16_16</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
</tr>
<tr class="row-odd"><td><p>16_16_16_16</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
</tr>
<tr class="row-even"><td><p>32</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
</tr>
<tr class="row-odd"><td><p>32_32</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
</tr>
<tr class="row-even"><td><p>32_32_32_32</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
</tr>
<tr class="row-odd"><td><p>10_10_10_2</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
</tr>
<tr class="row-even"><td><p>11_11_10</p></td>
<td><p>Unsupported</p></td>
<td><p>Unsupported</p></td>
<td><p>Unsupported</p></td>
<td><p>Unsupported</p></td>
<td><p>Required</p></td>
</tr>
<tr class="row-odd"><td><p>5_6_5</p></td>
<td><p>Unsupported</p></td>
<td><p>Unsupported</p></td>
<td><p>Required</p></td>
<td><p>Unsupported</p></td>
<td><p>Unsupported</p></td>
</tr>
<tr class="row-even"><td><p>5_5_5_1</p></td>
<td><p>Unsupported</p></td>
<td><p>Unsupported</p></td>
<td><p>Required</p></td>
<td><p>Unsupported</p></td>
<td><p>Unsupported</p></td>
</tr>
<tr class="row-odd"><td><p>4_4_4_4</p></td>
<td><p>Unsupported</p></td>
<td><p>Unsupported</p></td>
<td><p>Required</p></td>
<td><p>Unsupported</p></td>
<td><p>Unsupported</p></td>
</tr>
</tbody>
</table>
</section>
<section id="device-cache-settings">
<h3>Device Cache Settings<a class="headerlink" href="#device-cache-settings" title="Link to this heading">#</a></h3>
<p>There are two methods for device and kernel cache control:</p>
<ol class="arabic">
<li><p>Cache Size Configuration: Ability to configure larger size for SLM vs Data per Kernel instance.</p></li>
<li><p>Runtime Hint/preference for application to allow access to be Cached or not in Device Caches. For GPU device this is provided via two ways:</p>
<blockquote>
<div><ul class="simple">
<li><p>During Image creation via Flag</p></li>
<li><p>Kernel instruction</p></li>
</ul>
</div></blockquote>
</li>
</ol>
<p>The following pseudo-code demonstrates a basic sequence for Cache size
configuration:</p>
<pre class="literal-block">// Configure cache to support larger SLM
// Note: The cache setting is applied to each kernel.
<a class="reference internal" href="api.html#zekernelsetcacheconfig"><span class="std std-ref">zeKernelSetCacheConfig</span></a>(hKernel, <a class="reference internal" href="api.html#ze-cache-config-flags-t"><span class="std std-ref">ZE_CACHE_CONFIG_FLAG_LARGE_SLM</span></a>);</pre>
</section>
<section id="external-memory-import-and-export">
<span id="external-memory"></span><h3>External Memory Import and Export<a class="headerlink" href="#external-memory-import-and-export" title="Link to this heading">#</a></h3>
<p>External memory handles may be imported from other APIs, or exported for use in other APIs.
Importing and exporting external memory is an optional feature.
Devices may describe the types of external memory handles they support using <a class="reference internal" href="api.html#zedevicegetexternalmemoryproperties"><span class="std std-ref">zeDeviceGetExternalMemoryProperties</span></a>.</p>
<p>Importing and exporting external memory is supported for device and host memory allocations and images.</p>
<p>The following pseudo-code demonstrates how to allocate and export an external memory handle for a device memory allocation as a Linux dma_buf:</p>
<pre class="literal-block">// Set up the request for an exportable allocation
<a class="reference internal" href="api.html#ze-external-memory-export-desc-t"><span class="std std-ref">ze_external_memory_export_desc_t</span></a> export_desc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_DESC</span></a>,
    nullptr, // pNext
    <a class="reference internal" href="api.html#ze-external-memory-type-flags-t"><span class="std std-ref">ZE_EXTERNAL_MEMORY_TYPE_FLAG_DMA_BUF</span></a>
};

// Link the request into the allocation descriptor and allocate
alloc_desc.pNext = &amp;export_desc;
<a class="reference internal" href="api.html#zememallocdevice"><span class="std std-ref">zeMemAllocDevice</span></a>(hContext, &amp;alloc_desc, size, alignment, hDevice, &amp;ptr);

...

// Set up the request to export the external memory handle
<a class="reference internal" href="api.html#ze-external-memory-export-fd-t"><span class="std std-ref">ze_external_memory_export_fd_t</span></a> export_fd = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_FD</span></a>,
    nullptr, // pNext
    <a class="reference internal" href="api.html#ze-external-memory-type-flags-t"><span class="std std-ref">ZE_EXTERNAL_MEMORY_TYPE_FLAG_OPAQUE_FD</span></a>,
    0 // [out] fd
};

// Link the export request into the query
alloc_props.pNext = &amp;export_fd;
<a class="reference internal" href="api.html#zememgetallocproperties"><span class="std std-ref">zeMemGetAllocProperties</span></a>(hContext, ptr, &amp;alloc_props, nullptr);</pre>
<p>The following pseudo-code demonstrates how to import a Linux dma_buf as an external memory handle for a device memory allocation:</p>
<pre class="literal-block">// Set up the request to import the external memory handle
<a class="reference internal" href="api.html#ze-external-memory-import-fd-t"><span class="std std-ref">ze_external_memory_import_fd_t</span></a> import_fd = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMPORT_FD</span></a>,
    nullptr, // pNext
    <a class="reference internal" href="api.html#ze-external-memory-type-flags-t"><span class="std std-ref">ZE_EXTERNAL_MEMORY_TYPE_FLAG_DMA_BUF</span></a>,
    fd
};

// Link the request into the allocation descriptor and allocate
alloc_desc.pNext = &amp;import_fd;
<a class="reference internal" href="api.html#zememallocdevice"><span class="std std-ref">zeMemAllocDevice</span></a>(hContext, &amp;alloc_desc, size, alignment, hDevice, &amp;ptr);</pre>
<p>Another example, which the following pseudo-code demonstrates, is how to import a Linux dma_buf as an external
memory handle for <a class="reference internal" href="#images"><span class="std std-ref">Images</span></a>:</p>
<pre class="literal-block">// Set up the request to import the external memory handle
<a class="reference internal" href="api.html#ze-external-memory-import-fd-t"><span class="std std-ref">ze_external_memory_import_fd_t</span></a> import_fd = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMPORT_FD</span></a>,
    nullptr, // pNext
    <a class="reference internal" href="api.html#ze-external-memory-type-flags-t"><span class="std std-ref">ZE_EXTERNAL_MEMORY_TYPE_FLAG_DMA_BUF</span></a>,
    fd
};

// Link the request into the allocation descriptor and allocate
image_desc.pNext = &amp;import_fd; // extend ze_image_desc_t

// Setup matching image properties for imported image.
image_desc.width = import_width;
...

<a class="reference internal" href="api.html#zeimagecreate"><span class="std std-ref">zeImageCreate</span></a>(hContext, hDevice, &amp;image_desc, &amp;hImage);</pre>
</section>
</section>
<section id="command-queues-and-command-lists">
<h2>Command Queues and Command Lists<a class="headerlink" href="#command-queues-and-command-lists" title="Link to this heading">#</a></h2>
<p>The following are the motivations for separating a command queue from a command list:</p>
<ul class="simple">
<li><p>Command queues are mostly associated with physical device properties, such as the number of input streams.</p></li>
<li><p>Command queues provide (near) zero-latency access to the device.</p></li>
<li><p>Command lists are mostly associated with Host threads for simultaneous construction.</p></li>
<li><p>Command list construction can occur independently of command queue submission.</p></li>
</ul>
<p>The following diagram illustrates the hierarchy of command lists and command queues to the device:</p>
<img alt="../_images/core_queue.png" src="../_images/core_queue.png" />
<section id="command-queue-groups">
<h3>Command Queue Groups<a class="headerlink" href="#command-queue-groups" title="Link to this heading">#</a></h3>
<p>A command queue group represents a physical input stream, which represents one or more physical device engines.</p>
<section id="discovery">
<h4>Discovery<a class="headerlink" href="#discovery" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>The number and properties of command queue groups is queried by using <a class="reference internal" href="api.html#zedevicegetcommandqueuegroupproperties"><span class="std std-ref">zeDeviceGetCommandQueueGroupProperties</span></a>.</p></li>
<li><p>The number of physical engines within a group is queried from <a class="reference internal" href="api.html#ze-command-queue-group-properties-t"><span class="std std-ref">ze_command_queue_group_properties_t</span></a>.numQueues.</p></li>
<li><p>The types of commands supported by the group is queried from <a class="reference internal" href="api.html#ze-command-queue-group-properties-t"><span class="std std-ref">ze_command_queue_group_properties_t</span></a>.flags.</p></li>
<li><p>For example, if a command list is meant to be submitted to a copy-only engine,
then it must be created using a command queue group ordinal with
<a class="reference internal" href="api.html#ze-command-queue-group-property-flags-t"><span class="std std-ref">ZE_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COPY</span></a> set and <a class="reference internal" href="api.html#ze-command-queue-group-property-flags-t"><span class="std std-ref">ZE_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COMPUTE</span></a> not set,
and submitted to a command queue created using the same ordinal.</p></li>
</ul>
<p>The following pseudo-code demonstrates a basic sequence for discovery of command queue groups:</p>
<pre class="literal-block">// Discover all command queue groups
uint32_t cmdqueueGroupCount = 0;
<a class="reference internal" href="api.html#zedevicegetcommandqueuegroupproperties"><span class="std std-ref">zeDeviceGetCommandQueueGroupProperties</span></a>(hDevice, &amp;cmdqueueGroupCount, nullptr);

<a class="reference internal" href="api.html#ze-command-queue-group-properties-t"><span class="std std-ref">ze_command_queue_group_properties_t</span></a>* cmdqueueGroupProperties = (<a class="reference internal" href="api.html#ze-command-queue-group-properties-t"><span class="std std-ref">ze_command_queue_group_properties_t</span></a>*)
    allocate(cmdqueueGroupCount * sizeof(<a class="reference internal" href="api.html#ze-command-queue-group-properties-t"><span class="std std-ref">ze_command_queue_group_properties_t</span></a>));
cmdqueueGroupProperties[ i ].stype = <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_COMMAND_QUEUE_GROUP_PROPERTIES</span></a>;
cmdqueueGroupProperties[ i ].pNext = nullptr;
<a class="reference internal" href="api.html#zedevicegetcommandqueuegroupproperties"><span class="std std-ref">zeDeviceGetCommandQueueGroupProperties</span></a>(hDevice, &amp;cmdqueueGroupCount, cmdqueueGroupProperties);


// Find a command queue type that support compute
uint32_t computeQueueGroupOrdinal = cmdqueueGroupCount;
for( uint32_t i = 0; i &lt; cmdqueueGroupCount; ++i ) {
    if( cmdqueueGroupProperties[ i ].flags &amp; <a class="reference internal" href="api.html#ze-command-queue-group-property-flags-t"><span class="std std-ref">ZE_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COMPUTE</span></a> ) {
        computeQueueGroupOrdinal = i;
        break;
    }
}

if(computeQueueGroupOrdinal == cmdqueueGroupCount)
    return; // no compute queues found</pre>
</section>
</section>
<section id="command-queues">
<h3>Command Queues<a class="headerlink" href="#command-queues" title="Link to this heading">#</a></h3>
<p>A command queue represents a logical input stream to the device, tied to a physical input stream.</p>
<section id="creation">
<h4>Creation<a class="headerlink" href="#creation" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>At creation time, the command queue is explicitly bound to a command queue group via its ordinal.</p></li>
<li><p>Multiple command queues may be created that use the same command queue group. For example,
an application may create a command queue per Host thread with different scheduling priorities.</p></li>
<li><p>Multiple command queues created for the same command queue group on the same context,
may also share the same physical hardware context.</p></li>
<li><p>The maximum number of command queues an application can create is limited by device-specific
resources; e.g., the maximum number of logical hardware contexts supported by the device.
This can be queried from <a class="reference internal" href="api.html#ze-device-properties-t"><span class="std std-ref">ze_device_properties_t</span></a>.maxHardwareContexts.</p></li>
<li><p>The physical engine within a command queue group on which a command queue executes is virtualized
via its index, limited by the number of physical engines of the type of the command queue group,
i.e. <a class="reference internal" href="api.html#ze-command-queue-group-properties-t"><span class="std std-ref">ze_command_queue_group_properties_t</span></a>.numQueues.</p></li>
<li><p>The command queue index provides a mechanism for an application to indicate which command queues
can execute concurrently (different indices).</p></li>
<li><p>Command queues that do not share the same index may launch and execute concurrently.</p></li>
<li><p>Command queues that share the same index launch sequentially but may execute concurrently.</p></li>
<li><p>All command lists executed on a command queue are guaranteed to <strong>only</strong> execute on an engine from the
command queue group to which it is assigned; e.g., copy commands in a compute command list / queue will
execute via the compute engine, not the copy engine.</p></li>
<li><p>There is no guarantee that command lists submitted to command queues with different indices will execute concurrently,
only a possibility that they might execute concurrently.</p></li>
</ul>
<p>The following pseudo-code demonstrates a basic sequence for creation of command queues:</p>
<pre class="literal-block">// Create a command queue
<a class="reference internal" href="api.html#ze-command-queue-desc-t"><span class="std std-ref">ze_command_queue_desc_t</span></a> commandQueueDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_COMMAND_QUEUE_DESC</span></a>,
    nullptr,
    computeQueueGroupOrdinal,
    0, // index
    0, // flags
    <a class="reference internal" href="api.html#ze-command-queue-mode-t"><span class="std std-ref">ZE_COMMAND_QUEUE_MODE_DEFAULT</span></a>,
    <a class="reference internal" href="api.html#ze-command-queue-priority-t"><span class="std std-ref">ZE_COMMAND_QUEUE_PRIORITY_NORMAL</span></a>
};
ze_command_queue_handle_t hCommandQueue;
<a class="reference internal" href="api.html#zecommandqueuecreate"><span class="std std-ref">zeCommandQueueCreate</span></a>(hContext, hDevice, &amp;commandQueueDesc, &amp;hCommandQueue);
...</pre>
</section>
<section id="execution">
<h4>Execution<a class="headerlink" href="#execution" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>Command lists submitted to a command queue are <strong>immediately</strong> submitted to the device for execution.</p></li>
<li><p>Submitting multiple commands lists in a single submission allows an implementation the opportunity to optimize across command lists.</p></li>
<li><p>Command queue submission is free-threaded, allowing multiple Host threads to share the same command queue.</p></li>
<li><p>If multiple Host threads enter the same command queue simultaneously, then execution order is undefined.</p></li>
<li><p>Command lists can only be executed on a command queue with an identical command queue group ordinal.</p></li>
</ul>
</section>
<section id="destruction">
<h4>Destruction<a class="headerlink" href="#destruction" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>The application is responsible for making sure the device is not currently
executing from a command queue before it is deleted. This is
typically done by tracking command queue fences, but may also be
handled by calling <a class="reference internal" href="api.html#zecommandqueuesynchronize"><span class="std std-ref">zeCommandQueueSynchronize</span></a>.</p></li>
</ul>
</section>
</section>
<section id="command-lists">
<h3>Command Lists<a class="headerlink" href="#command-lists" title="Link to this heading">#</a></h3>
<p>A command list represents a sequence of commands for execution on a command queue.</p>
<section id="creation-1">
<span id="id3"></span><h4>Creation<a class="headerlink" href="#creation-1" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>A command list is created for a device to allow device-specific appending of commands.</p></li>
<li><p>A command list is created for execution on a specific type of command queue, specified using
the command queue group ordinal.</p></li>
<li><p>A command list can be copied to create another command list. The application may use this
to copy a command list for use on a different device.</p></li>
</ul>
</section>
<section id="appending">
<h4>Appending<a class="headerlink" href="#appending" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>There is no implicit binding of command lists to Host threads. Therefore, an
application may share a command list handle across multiple Host threads. However,
the application is responsible for ensuring that multiple Host threads do not access
the same command list simultaneously.</p></li>
<li><p>By default, commands are started in the same order in which they are appended.
However, an application may allow the driver to optimize the ordering by using
<a class="reference internal" href="api.html#ze-command-list-flags-t"><span class="std std-ref">ZE_COMMAND_LIST_FLAG_RELAXED_ORDERING</span></a>. Reordering is guaranteed to only occur
between barriers and synchronization primitives.</p></li>
<li><p>By default, commands submitted to a command list are optimized for execution by
balancing both device throughput and Host latency.</p></li>
<li><p>For very low-level latency usage-models, applications should use immediate command lists.</p></li>
<li><p>For usage-models where maximum throughput is desired, applications should
use <a class="reference internal" href="api.html#ze-command-list-flags-t"><span class="std std-ref">ZE_COMMAND_LIST_FLAG_MAXIMIZE_THROUGHPUT</span></a>. This flag will indicate to the driver
it may perform additional device-specific optimizations.</p></li>
</ul>
<p>The following pseudo-code demonstrates a basic sequence for creation of command lists:</p>
<pre class="literal-block">// Create a command list
<a class="reference internal" href="api.html#ze-command-list-desc-t"><span class="std std-ref">ze_command_list_desc_t</span></a> commandListDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_COMMAND_LIST_DESC</span></a>,
    nullptr,
    computeQueueGroupOrdinal,
    0 // flags
};
ze_command_list_handle_t hCommandList;
<a class="reference internal" href="api.html#zecommandlistcreate"><span class="std std-ref">zeCommandListCreate</span></a>(hContext, hDevice, &amp;commandListDesc, &amp;hCommandList);
...</pre>
</section>
<section id="submission">
<h4>Submission<a class="headerlink" href="#submission" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>There is no implicit association between a command list and a command queue.
Therefore, a command list may be submitted to any or multiple command queues.</p></li>
<li><p>By definition, a command list cannot be executed concurrently on multiple command queues.</p></li>
<li><p>The application is responsible for calling close before submission to a command queue.</p></li>
<li><p>Command lists do not inherit state from other command lists executed on the same
command queue.  i.e. each command list begins execution in its own default state.</p></li>
<li><p>A command list may be submitted multiple times.  It is up to the application to ensure
that the command list can be executed multiple times.
For example, events must be explicitly reset prior to re-execution.</p></li>
</ul>
<p>The following pseudo-code demonstrates submission of commands to a command queue, via a command list:</p>
<pre class="literal-block">...
// finished appending commands (typically done on another thread)
<a class="reference internal" href="api.html#zecommandlistclose"><span class="std std-ref">zeCommandListClose</span></a>(hCommandList);

// Execute command list in command queue
<a class="reference internal" href="api.html#zecommandqueueexecutecommandlists"><span class="std std-ref">zeCommandQueueExecuteCommandLists</span></a>(hCommandQueue, 1, &amp;hCommandList, nullptr);

// synchronize host and device
<a class="reference internal" href="api.html#zecommandqueuesynchronize"><span class="std std-ref">zeCommandQueueSynchronize</span></a>(hCommandQueue, UINT32_MAX);

// Reset (recycle) command list for new commands
<a class="reference internal" href="api.html#zecommandlistreset"><span class="std std-ref">zeCommandListReset</span></a>(hCommandList);
...</pre>
</section>
<section id="recycling">
<h4>Recycling<a class="headerlink" href="#recycling" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>A command list may be recycled to avoid the overhead of frequent creation and destruction.</p></li>
<li><p>The application is responsible for making sure the device is not currently
executing from a command list before it is reset. This should be
handled by tracking a completion event associated with the command list.</p></li>
<li><p>The application is responsible for making sure the device is not currently
executing from a command list before it is deleted. This should be
handled by tracking a completion event associated with the command list.</p></li>
</ul>
</section>
<section id="low-latency-immediate-command-lists">
<h4>Low-Latency Immediate Command Lists<a class="headerlink" href="#low-latency-immediate-command-lists" title="Link to this heading">#</a></h4>
<p>A special type of command list can be used for very low-latency submission usage-models.</p>
<ul class="simple">
<li><p>An immediate command list is both a command list and an implicit command queue.</p></li>
<li><p>An immediate command list is created using a command queue descriptor.</p></li>
<li><p>Commands appended into an immediate command list are immediately executed on the device.</p></li>
<li><p>Commands appended into an immediate command list may execute synchronously, by blocking until the command is complete.</p></li>
<li><p>An immediate command list is not required to be closed or reset. However, usage will be honored, and expected behaviors will be followed.</p></li>
</ul>
<p>The following pseudo-code demonstrates a basic sequence for creation and usage of immediate command lists:</p>
<pre class="literal-block">// Create an immediate command list
<a class="reference internal" href="api.html#ze-command-queue-desc-t"><span class="std std-ref">ze_command_queue_desc_t</span></a> commandQueueDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_COMMAND_QUEUE_DESC</span></a>,
    nullptr,
    computeQueueGroupOrdinal,
    0, // index
    0, // flags
    <a class="reference internal" href="api.html#ze-command-queue-mode-t"><span class="std std-ref">ZE_COMMAND_QUEUE_MODE_DEFAULT</span></a>,
    <a class="reference internal" href="api.html#ze-command-queue-priority-t"><span class="std std-ref">ZE_COMMAND_QUEUE_PRIORITY_NORMAL</span></a>
};
ze_command_list_handle_t hCommandList;
<a class="reference internal" href="api.html#zecommandlistcreateimmediate"><span class="std std-ref">zeCommandListCreateImmediate</span></a>(hContext, hDevice, &amp;commandQueueDesc, &amp;hCommandList);

// Immediately submit a kernel to the device
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);
...</pre>
</section>
</section>
</section>
<section id="synchronization-primitives">
<h2>Synchronization Primitives<a class="headerlink" href="#synchronization-primitives" title="Link to this heading">#</a></h2>
<p>There are two types of synchronization primitives:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#fences">Fences</a> - used to communicate to the host that command queue execution has completed.</p></li>
<li><p><a class="reference internal" href="#events">Events</a> - used as fine-grain host-to-device, device-to-host or device-to-device execution and memory dependencies.</p></li>
</ol>
<p>The following are the motivations for separating the different types of synchronization primitives:</p>
<ul>
<li><p>Allows device-specific optimizations for certain types of primitives:</p>
<blockquote>
<div><ul class="simple">
<li><p>Fences may share device memory with all other fences within the same command queue.</p></li>
<li><p>Events may be implemented using pipelined operations as part of the program execution.</p></li>
<li><p>Fences are implicit, coarse-grain execution and memory barriers.</p></li>
<li><p>Events optionally cause fine-grain execution and memory barriers.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Allows distinction on which type of primitive may be shared across devices.</p></li>
</ul>
<p>Generally. Events are generic synchronization primitives that can be used across many different usage-models, including those of fences.
However, this generality comes with some cost in memory overhead and efficiency.</p>
<section id="fences">
<span id="id4"></span><h3>Fences<a class="headerlink" href="#fences" title="Link to this heading">#</a></h3>
<p>A fence is a heavyweight synchronization primitive used to communicate to the host that command list execution has completed.</p>
<ul class="simple">
<li><p>A fence is associated with a single command queue.</p></li>
<li><p>A fence can only be signaled from a device’s command queue (e.g. between execution of command lists) and can only be waited upon from the host.</p></li>
<li><p>A fence guarantees both execution completion and memory coherency, across the device and host, prior to being signaled.</p></li>
<li><p>A fence only has two states: not signaled and signaled.</p></li>
<li><p>A fence doesn’t implicitly reset. Signaling a signaled fence (or resetting an unsignaled fence) is valid and has no effect on the state of the fence.</p></li>
<li><p>A fence can only be reset from the Host.</p></li>
<li><p>A fence cannot be shared across processes.</p></li>
</ul>
<p>The following pseudo-code demonstrates a sequence for creation, submission and querying of a fence:</p>
<pre class="literal-block">// Create fence
<a class="reference internal" href="api.html#ze-fence-desc-t"><span class="std std-ref">ze_fence_desc_t</span></a> fenceDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_FENCE_DESC</span></a>,
    nullptr,
    0 // flags
};
ze_fence_handle_t hFence;
<a class="reference internal" href="api.html#zefencecreate"><span class="std std-ref">zeFenceCreate</span></a>(hCommandQueue, &amp;fenceDesc, &amp;hFence);

// Execute a command list with a signal of the fence
<a class="reference internal" href="api.html#zecommandqueueexecutecommandlists"><span class="std std-ref">zeCommandQueueExecuteCommandLists</span></a>(hCommandQueue, 1, &amp;hCommandList, hFence);

// Wait for fence to be signaled
<a class="reference internal" href="api.html#zefencehostsynchronize"><span class="std std-ref">zeFenceHostSynchronize</span></a>(hFence, UINT32_MAX);
<a class="reference internal" href="api.html#zefencereset"><span class="std std-ref">zeFenceReset</span></a>(hFence);
...</pre>
<p>The primary usage model for fences is to notify the Host when a command list has finished execution to allow:</p>
<ul class="simple">
<li><p>Recycling of memory and images</p></li>
<li><p>Recycling of command lists</p></li>
<li><p>Recycling of other synchronization primitives</p></li>
<li><p>Explicit memory residency.</p></li>
</ul>
<p>The following diagram illustrates fences signaled after command lists on execution:</p>
<img alt="../_images/core_fence.png" src="../_images/core_fence.png" />
</section>
<section id="events">
<span id="id5"></span><h3>Events<a class="headerlink" href="#events" title="Link to this heading">#</a></h3>
<p>An event is used to communicate fine-grain host-to-device, device-to-host or device-to-device dependencies have completed.</p>
<ul>
<li><p>An event can be:</p>
<blockquote>
<div><ul class="simple">
<li><p>Signaled from within a device’s command list and waited upon within the same command list</p></li>
<li><p>Signaled from within a device’s command list and waited upon from the host, another command queue or another device</p></li>
<li><p>Signaled from the host, and waited upon from within a device’s command list.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>An event only has two states: not signaled and signaled.</p></li>
<li><p>An event doesn’t implicitly reset. Signaling a signaled event (or resetting an unsignaled event) is valid and has no effect on the state of the event.</p></li>
<li><p>An event can be explicitly reset from the Host or device.</p></li>
<li><p>An event can be appended into multiple command lists simultaneously.</p></li>
<li><p>An event can be shared across devices and processes.</p></li>
<li><p>An event can invoke an execution and/or memory barrier; which should be used sparingly to avoid device underutilization.</p></li>
<li><p>There are no protections against events causing deadlocks, such as circular waits scenarios.</p>
<blockquote>
<div><ul class="simple">
<li><p>These problems are left to the application to avoid.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>An event intended to be signaled by the host, another command queue or another device after command list submission to a command queue may prevent subsequent forward progress within the command queue itself.</p>
<blockquote>
<div><ul class="simple">
<li><p>This can create bubbles in the pipeline or deadlock situations if not correctly scheduled.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>An event pool is used for creation of individual events:</p>
<ul class="simple">
<li><p>An event pool reduces the cost of creating multiple events by allowing underlying device allocations to be shared by events with the same properties</p></li>
<li><p>An event pool can be shared via <a class="reference internal" href="#inter-process-communication"><span class="std std-ref">Inter-Process Communication</span></a>; allowing sharing blocks of events rather than sharing each individual event</p></li>
</ul>
<p>The following pseudo-code demonstrates a sequence for creation and submission of an event:</p>
<pre class="literal-block">// Create event pool
<a class="reference internal" href="api.html#ze-event-pool-desc-t"><span class="std std-ref">ze_event_pool_desc_t</span></a> eventPoolDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EVENT_POOL_DESC</span></a>,
    nullptr,
    <a class="reference internal" href="api.html#ze-event-pool-flags-t"><span class="std std-ref">ZE_EVENT_POOL_FLAG_HOST_VISIBLE</span></a>, // all events in pool are visible to Host
    1 // count
};
ze_event_pool_handle_t hEventPool;
<a class="reference internal" href="api.html#zeeventpoolcreate"><span class="std std-ref">zeEventPoolCreate</span></a>(hContext, &amp;eventPoolDesc, 0, nullptr, &amp;hEventPool);

<a class="reference internal" href="api.html#ze-event-desc-t"><span class="std std-ref">ze_event_desc_t</span></a> eventDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EVENT_DESC</span></a>,
    nullptr,
    0, // index
    0, // no additional memory/cache coherency required on signal
    <a class="reference internal" href="api.html#ze-event-scope-flags-t"><span class="std std-ref">ZE_EVENT_SCOPE_FLAG_HOST</span></a>  // ensure memory coherency across device and Host after event completes
};
ze_event_handle_t hEvent;
<a class="reference internal" href="api.html#zeeventcreate"><span class="std std-ref">zeEventCreate</span></a>(hEventPool, &amp;eventDesc, &amp;hEvent);

// Append a signal of an event into the command list after the kernel executes
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel1, &amp;launchArgs, hEvent, 0, nullptr);

// Execute the command list with the signal
<a class="reference internal" href="api.html#zecommandqueueexecutecommandlists"><span class="std std-ref">zeCommandQueueExecuteCommandLists</span></a>(hCommandQueue, 1, &amp;hCommandList, nullptr);

// Wait on event to complete
<a class="reference internal" href="api.html#zeeventhostsynchronize"><span class="std std-ref">zeEventHostSynchronize</span></a>(hEvent, 0);
...</pre>
<p>The following diagram illustrates a dependency between command lists using events:</p>
<img alt="../_images/core_event.png" src="../_images/core_event.png" />
<section id="kernel-timestamp-events">
<h4>Kernel Timestamp Events<a class="headerlink" href="#kernel-timestamp-events" title="Link to this heading">#</a></h4>
<p>A kernel timestamp event is a special type of event that records device timestamps at the start and end of the execution of kernels. The primary motivation for kernel timestamps is to provide a duration of execution.  For consistency and orthogonality, kernel timestamps are also supported for non-kernel operations. Kernel timestamps execute along a device timeline but because of limited range may wrap unexpectedly. Because of this, the temporal order of two kernel timestamps shouldn’t be inferred despite coincidental START/END values. <a class="reference internal" href="api.html#zecommandlistappendwriteglobaltimestamp"><span class="std std-ref">zeCommandListAppendWriteGlobalTimestamp</span></a> provides a similar mechanism but with maximum range. Timestamps from <a class="reference internal" href="api.html#zecommandlistappendwriteglobaltimestamp"><span class="std std-ref">zeCommandListAppendWriteGlobalTimestamp</span></a> and kernel timestamp events should not be inferred as equivalent even if reported within identical ranges.</p>
<ul class="simple">
<li><p>The duration of a kernel timestamp for <a class="reference internal" href="api.html#zecommandlistappendsignalevent"><span class="std std-ref">zeCommandListAppendSignalEvent</span></a> and <a class="reference internal" href="api.html#zeeventhostsignal"><span class="std std-ref">zeEventHostSignal</span></a> is undefined. However, for consistency and orthogonality the event will report correctly as signaled when used by other event API functionality.</p></li>
<li><p>A kernel timestamp event result can be queried using either <a class="reference internal" href="api.html#zeeventquerykerneltimestamp"><span class="std std-ref">zeEventQueryKernelTimestamp</span></a> or <a class="reference internal" href="api.html#zecommandlistappendquerykerneltimestamps"><span class="std std-ref">zeCommandListAppendQueryKernelTimestamps</span></a></p></li>
<li><p>The <a class="reference internal" href="api.html#ze-kernel-timestamp-result-t"><span class="std std-ref">ze_kernel_timestamp_result_t</span></a> contains both the per-context and global timestamp values at the start and end of the kernel’s execution</p></li>
<li><p>Since these counters are only 32bits, the application must detect and handle counter wrapping when calculating execution time</p></li>
</ul>
<pre class="literal-block">// Get timestamp frequency
const double timestampFreq = NS_IN_SEC / device_properties.timerResolution;
const uint64_t timestampMaxValue = ~(-1L &lt;&lt; device_properties.kernelTimestampValidBits);

// Create event pool
<a class="reference internal" href="api.html#ze-event-pool-desc-t"><span class="std std-ref">ze_event_pool_desc_t</span></a> tsEventPoolDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EVENT_POOL_DESC</span></a>,
    nullptr,
    <a class="reference internal" href="api.html#ze-event-pool-flags-t"><span class="std std-ref">ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP</span></a>, // all events in pool are kernel timestamps
    1 // count
};
ze_event_pool_handle_t hTSEventPool;
<a class="reference internal" href="api.html#zeeventpoolcreate"><span class="std std-ref">zeEventPoolCreate</span></a>(hContext, &amp;tsEventPoolDesc, 0, nullptr, &amp;hTSEventPool);

<a class="reference internal" href="api.html#ze-event-desc-t"><span class="std std-ref">ze_event_desc_t</span></a> tsEventDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EVENT_DESC</span></a>,
    nullptr,
    0, // index
    0, // no additional memory/cache coherency required on signal
    0  // no additional memory/cache coherency required on wait
};
ze_event_handle_t hTSEvent;
<a class="reference internal" href="api.html#zeeventcreate"><span class="std std-ref">zeEventCreate</span></a>(hEventPool, &amp;tsEventDesc, &amp;hTSEvent);

// allocate memory for results
<a class="reference internal" href="api.html#ze-device-mem-alloc-desc-t"><span class="std std-ref">ze_device_mem_alloc_desc_t</span></a> tsResultDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_DEVICE_MEM_ALLOC_DESC</span></a>,
    nullptr,
    0, // flags
    0  // ordinal
};
<a class="reference internal" href="api.html#ze-kernel-timestamp-result-t"><span class="std std-ref">ze_kernel_timestamp_result_t</span></a>* tsResult = nullptr;
<a class="reference internal" href="api.html#zememallocdevice"><span class="std std-ref">zeMemAllocDevice</span></a>(hContext, &amp;tsResultDesc, sizeof(<a class="reference internal" href="api.html#ze-kernel-timestamp-result-t"><span class="std std-ref">ze_kernel_timestamp_result_t</span></a>), sizeof(uint32_t), hDevice, &amp;tsResult);

// Append a signal of a timestamp event into the command list after the kernel executes
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel1, &amp;launchArgs, hTSEvent, 0, nullptr);

// Append a query of a timestamp event into the command list
<a class="reference internal" href="api.html#zecommandlistappendquerykerneltimestamps"><span class="std std-ref">zeCommandListAppendQueryKernelTimestamps</span></a>(hCommandList, 1, &amp;hTSEvent, tsResult, nullptr, hEvent, 1, &amp;hTSEvent);

// Execute the command list with the signal
<a class="reference internal" href="api.html#zecommandqueueexecutecommandlists"><span class="std std-ref">zeCommandQueueExecuteCommandLists</span></a>(hCommandQueue, 1, &amp;hCommandList, nullptr);

// Wait on event to complete
<a class="reference internal" href="api.html#zeeventhostsynchronize"><span class="std std-ref">zeEventHostSynchronize</span></a>(hEvent, 0);

// Calculation execution time(s)
double globalTimeInNs = ( tsResult-&gt;global.kernelEnd &gt;= tsResult-&gt;global.kernelStart )
    ? ( tsResult-&gt;global.kernelEnd - tsResult-&gt;global.kernelStart ) * timestampFreq
    : (( timestampMaxValue - tsResult-&gt;global.kernelStart) + tsResult-&gt;global.kernelEnd + 1 ) * timestampFreq;

double contextTimeInNs = ( tsResult-&gt;context.kernelEnd &gt;= tsResult-&gt;context.kernelStart )
    ? ( tsResult-&gt;context.kernelEnd - tsResult-&gt;context.kernelStart ) * timestampFreq
    : (( timestampMaxValue - tsResult-&gt;context.kernelStart) + tsResult-&gt;context.kernelEnd + 1 ) * timestampFreq;
...</pre>
</section>
</section>
</section>
<section id="barriers">
<h2>Barriers<a class="headerlink" href="#barriers" title="Link to this heading">#</a></h2>
<p>There are two types of barriers:</p>
<ol class="arabic simple">
<li><p><strong>Execution Barriers</strong> - used to communicate execution dependencies between commands within a command list or across command queues, devices and/or Host.</p></li>
<li><p><strong>Memory Barriers</strong> - used to communicate memory coherency dependencies between commands within a command list or across command queues, devices and/or Host.</p></li>
</ol>
<p>The following pseudo-code demonstrates a sequence for submission of a brute-force execution and global memory barrier:</p>
<pre class="literal-block"><a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);

// Append a barrier into a command list to ensure hKernel1 completes before hKernel2 begins
<a class="reference internal" href="api.html#zecommandlistappendbarrier"><span class="std std-ref">zeCommandListAppendBarrier</span></a>(hCommandList, nullptr, 0, nullptr);

<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);
...</pre>
<section id="execution-barriers">
<h3>Execution Barriers<a class="headerlink" href="#execution-barriers" title="Link to this heading">#</a></h3>
<p>Commands executed on a command list are only guaranteed to start in the same order in which they are submitted; i.e. there is no implicit definition of the order of completion.</p>
<ul class="simple">
<li><p>Fences provide implicit, coarse-grain control to indicate that all previous commands must complete prior to the fence being signaled.</p></li>
<li><p>Events provide explicit, fine-grain control over execution dependencies between commands; allowing more opportunities for concurrent execution and higher device utilization.</p></li>
</ul>
<p>The following pseudo-code demonstrates a sequence for submission of a fine-grain execution-only dependency using events:</p>
<pre class="literal-block"><a class="reference internal" href="api.html#ze-event-desc-t"><span class="std std-ref">ze_event_desc_t</span></a> event1Desc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EVENT_DESC</span></a>,
    nullptr,
    0, // index
    0, // no additional memory/cache coherency required on signal
    0  // no additional memory/cache coherency required on wait
};
ze_event_handle_t hEvent1;
<a class="reference internal" href="api.html#zeeventcreate"><span class="std std-ref">zeEventCreate</span></a>(hEventPool, &amp;event1Desc, &amp;hEvent1);

// Ensure hKernel1 completes before signaling hEvent1
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel1, &amp;launchArgs, hEvent1, 0, nullptr);

// Ensure hEvent1 is signaled before starting hKernel2
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel2, &amp;launchArgs, nullptr, 1, &amp;hEvent1);
...</pre>
</section>
<section id="memory-barriers">
<h3>Memory Barriers<a class="headerlink" href="#memory-barriers" title="Link to this heading">#</a></h3>
<p>Commands executed on a command list are <em>not</em> guaranteed to maintain memory coherency with other commands;
i.e. there is no implicit memory or cache coherency.</p>
<ul class="simple">
<li><p>Fences provide implicit, coarse-grain control to indicate that all caches and memory are coherent across the device and Host prior to the fence being signaled.</p></li>
<li><p>Events provide explicit, fine-grain control over cache and memory coherency dependencies between commands; allowing more opportunities for concurrent execution and higher device utilization.</p></li>
</ul>
<p>The following pseudo-code demonstrates a sequence for submission of a fine-grain memory dependency using events:</p>
<pre class="literal-block"><a class="reference internal" href="api.html#ze-event-desc-t"><span class="std std-ref">ze_event_desc_t</span></a> event1Desc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EVENT_DESC</span></a>,
    nullptr,
    0, // index
    <a class="reference internal" href="api.html#ze-event-scope-flags-t"><span class="std std-ref">ZE_EVENT_SCOPE_FLAG_DEVICE</span></a>, // ensure memory coherency across device before event signaled
    0  // no additional memory/cache coherency required on wait
};
ze_event_handle_t hEvent1;
<a class="reference internal" href="api.html#zeeventcreate"><span class="std std-ref">zeEventCreate</span></a>(hEventPool, &amp;event1Desc, &amp;hEvent1);

// Ensure hKernel1 memory writes are fully coherent across the device before signaling hEvent1
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel1, &amp;launchArgs, hEvent1, 0, nullptr);

// Ensure hEvent1 is signaled before starting hKernel2
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel2, &amp;launchArgs, nullptr, 1, &amp;hEvent1);
...</pre>
</section>
<section id="range-based-memory-barriers">
<h3>Range-based Memory Barriers<a class="headerlink" href="#range-based-memory-barriers" title="Link to this heading">#</a></h3>
<p>Range-based memory barriers provide explicit control of which cachelines
require coherency.</p>
<p>The following pseudo-code demonstrates a sequence for submission of a range-based memory barrier:</p>
<pre class="literal-block"><a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel1, &amp;launchArgs, nullptr, 0, nullptr);

// Ensure memory range is fully coherent across the device after hKernel1 and before hKernel2
<a class="reference internal" href="api.html#zecommandlistappendmemoryrangesbarrier"><span class="std std-ref">zeCommandListAppendMemoryRangesBarrier</span></a>(hCommandList, 1, &amp;size, &amp;ptr, nullptr, 0, nullptr);

<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel2, &amp;launchArgs, nullptr, 0, nullptr);
...</pre>
</section>
</section>
<section id="modules-and-kernels">
<h2>Modules and Kernels<a class="headerlink" href="#modules-and-kernels" title="Link to this heading">#</a></h2>
<p>There are multiple levels of constructs needed for executing kernels on the device:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#modules">Modules</a> represent a single translation unit that consists of kernels that have been compiled together.</p></li>
<li><p><a class="reference internal" href="#kernels">Kernels</a> represent the kernel within the module that will be launched directly from a command list.</p></li>
</ol>
<p>The following diagram provides a high-level overview of the major parts
of the system.</p>
<img alt="../_images/core_module.png" src="../_images/core_module.png" />
<section id="modules">
<span id="id6"></span><h3>Modules<a class="headerlink" href="#modules" title="Link to this heading">#</a></h3>
<p>Modules can be created from an IL or directly from native format using <a class="reference internal" href="api.html#zemodulecreate"><span class="std std-ref">zeModuleCreate</span></a>.</p>
<ul class="simple">
<li><p><a class="reference internal" href="api.html#zemodulecreate"><span class="std std-ref">zeModuleCreate</span></a> takes a format argument that specifies the input format.</p></li>
<li><p><a class="reference internal" href="api.html#zemodulecreate"><span class="std std-ref">zeModuleCreate</span></a> performs a compilation step when format is IL.</p></li>
</ul>
<p>The following pseudo-code demonstrates a sequence for creating a module from an OpenCL kernel:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">__kernel</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">image_scaling</span><span class="p">(</span><span class="w"> </span><span class="n">__read_only</span><span class="w">  </span><span class="n">image2d_t</span><span class="w"> </span><span class="n">src_img</span><span class="p">,</span>
<span class="w">                             </span><span class="n">__write_only</span><span class="w"> </span><span class="n">image2d_t</span><span class="w"> </span><span class="n">dest_img</span><span class="p">,</span>
<span class="w">                                          </span><span class="n">uint</span><span class="w"> </span><span class="n">WIDTH</span><span class="p">,</span><span class="w">     </span><span class="c1">// resized width</span>
<span class="w">                                          </span><span class="n">uint</span><span class="w"> </span><span class="n">HEIGHT</span><span class="w"> </span><span class="p">)</span><span class="w">   </span><span class="c1">// resized height</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">int2</span><span class="w">       </span><span class="n">coor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">int2</span><span class="p">)(</span><span class="w"> </span><span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">get_global_id</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">float2</span><span class="w"> </span><span class="n">normCoor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convert_float2</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">float2</span><span class="p">)(</span><span class="w"> </span><span class="n">WIDTH</span><span class="p">,</span><span class="w"> </span><span class="n">HEIGHT</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="n">float4</span><span class="w">    </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_imagef</span><span class="p">(</span><span class="w"> </span><span class="n">src_img</span><span class="p">,</span><span class="w"> </span><span class="n">SMPL_PREF</span><span class="p">,</span><span class="w"> </span><span class="n">normCoor</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="n">write_imagef</span><span class="p">(</span><span class="w"> </span><span class="n">dest_img</span><span class="p">,</span><span class="w"> </span><span class="n">coor</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<pre class="literal-block">// OpenCL C kernel has been compiled to SPIRV IL (pImageScalingIL)
<a class="reference internal" href="api.html#ze-module-desc-t"><span class="std std-ref">ze_module_desc_t</span></a> moduleDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_MODULE_DESC</span></a>,
    nullptr,
    <a class="reference internal" href="api.html#ze-module-format-t"><span class="std std-ref">ZE_MODULE_FORMAT_IL_SPIRV</span></a>,
    ilSize,
    pImageScalingIL,
    nullptr,
    nullptr
};
ze_module_handle_t hModule;
<a class="reference internal" href="api.html#zemodulecreate"><span class="std std-ref">zeModuleCreate</span></a>(hContext, hDevice, &amp;moduleDesc, &amp;hModule, nullptr);
...</pre>
<section id="module-build-options">
<h4>Module Build Options<a class="headerlink" href="#module-build-options" title="Link to this heading">#</a></h4>
<p>Module build options can be passed with <a class="reference internal" href="api.html#ze-module-desc-t"><span class="std std-ref">ze_module_desc_t</span></a> as a string.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Build Option</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Device Support</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>-ze-opt-disable</p></td>
<td><p>Disable optimizations.</p></td>
<td><p>Disabled</p></td>
<td><p>All</p></td>
</tr>
<tr class="row-odd"><td><p>-ze-opt-level</p></td>
<td><p>Specifies optimization level for compiler. Levels are implementation specific.</p>
<blockquote>
<div><ul class="simple">
<li><p>0 is no optimizations (equivalent to ze-opt-disable)</p></li>
<li><p>1 is optimize minimally (may be the same as 2)</p></li>
<li><p>2 is optimize more (default)</p></li>
</ul>
</div></blockquote>
</td>
<td><p>2</p></td>
<td><p>All</p></td>
</tr>
<tr class="row-even"><td><p>-ze-opt-greater-than-4GB-buffer-required</p></td>
<td><p>Use 64-bit offset calculations for buffers.</p></td>
<td><p>Disabled</p></td>
<td><p>GPU</p></td>
</tr>
<tr class="row-odd"><td><p>-ze-opt-large-register-file</p></td>
<td><p>Increase number of registers available to threads.</p></td>
<td><p>Disabled</p></td>
<td><p>GPU</p></td>
</tr>
<tr class="row-even"><td><p>-ze-opt-has-buffer-offset-arg</p></td>
<td><p>Extend stateless to stateful optimization to more cases with the use of additional offset (e.g. 64-bit pointer to binding table with 32-bit offset).</p></td>
<td><p>Disabled</p></td>
<td><p>GPU</p></td>
</tr>
<tr class="row-odd"><td><p>-g</p></td>
<td><p>Include debugging information.</p></td>
<td><p>Disabled</p></td>
<td><p>GPU</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-specialization-constants">
<h4>Module Specialization Constants<a class="headerlink" href="#module-specialization-constants" title="Link to this heading">#</a></h4>
<p>SPIR-V supports specialization constants that allow certain constants to be updated to new
values during runtime execution. Each specialization constant in SPIR-V has an identifier
and default value. The <a class="reference internal" href="api.html#zemodulecreate"><span class="std std-ref">zeModuleCreate</span></a> function allows for an array of constants and their
corresponding identifiers to be passed in to override the constants in the SPIR-V module.</p>
<pre class="literal-block">// Spec constant overrides for group size.
<a class="reference internal" href="api.html#ze-module-constants-t"><span class="std std-ref">ze_module_constants_t</span></a> specConstants = {
    3,
    pGroupSizeIds,
    pGroupSizeValues
};
// OpenCL C kernel has been compiled to SPIRV IL (pImageScalingIL)
<a class="reference internal" href="api.html#ze-module-desc-t"><span class="std std-ref">ze_module_desc_t</span></a> moduleDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_MODULE_DESC</span></a>,
    nullptr,
    <a class="reference internal" href="api.html#ze-module-format-t"><span class="std std-ref">ZE_MODULE_FORMAT_IL_SPIRV</span></a>,
    ilSize,
    pImageScalingIL,
    nullptr,
    &amp;specConstants
};
ze_module_handle_t hModule;
<a class="reference internal" href="api.html#zemodulecreate"><span class="std std-ref">zeModuleCreate</span></a>(hContext, hDevice, &amp;moduleDesc, &amp;hModule, nullptr);
...</pre>
<p>Note: Specialization constants are only handled at module create time and therefore if
you need to change them then you’ll need to compile a new module.</p>
</section>
<section id="module-build-log">
<h4>Module Build Log<a class="headerlink" href="#module-build-log" title="Link to this heading">#</a></h4>
<p>The <a class="reference internal" href="api.html#zemodulecreate"><span class="std std-ref">zeModuleCreate</span></a> function can optionally generate a build log object ze_module_build_log_handle_t.</p>
<pre class="literal-block">...
ze_module_build_log_handle_t buildlog;
<a class="reference internal" href="api.html#ze-result-t"><span class="std std-ref">ze_result_t</span></a> result = <a class="reference internal" href="api.html#zemodulecreate"><span class="std std-ref">zeModuleCreate</span></a>(hContext, hDevice, &amp;desc, &amp;module, &amp;buildlog);

// Only save build logs for module creation errors.
if (result != <a class="reference internal" href="api.html#ze-result-t"><span class="std std-ref">ZE_RESULT_SUCCESS</span></a>)
{
    size_t szLog = 0;
    <a class="reference internal" href="api.html#zemodulebuildloggetstring"><span class="std std-ref">zeModuleBuildLogGetString</span></a>(buildlog, &amp;szLog, nullptr);

    char_t* strLog = allocate(szLog);
    <a class="reference internal" href="api.html#zemodulebuildloggetstring"><span class="std std-ref">zeModuleBuildLogGetString</span></a>(buildlog, &amp;szLog, strLog);

    // Save log to disk.
    ...

    free(strLog);
}

<a class="reference internal" href="api.html#zemodulebuildlogdestroy"><span class="std std-ref">zeModuleBuildLogDestroy</span></a>(buildlog);</pre>
</section>
<section id="dynamically-linked-modules">
<h4>Dynamically Linked Modules<a class="headerlink" href="#dynamically-linked-modules" title="Link to this heading">#</a></h4>
<p>Modules may be interdependent, i.e., a module may contain functions and global variables that are used and defined by different modules. Such a module is said to have both import as well as export linkage requirements. Private variables are not transferrable between linked modules, i.e., their visibility is limited to the module in which they are defined. Only global variables or static values passed to linked functions are visible between linked modules. All the import linkage requirements of a module must be satisfied before a kernel can be created from that module. Modules that have no imports do not need to be linked. Dynamically linking modules together is performed using <a class="reference internal" href="api.html#zemoduledynamiclink"><span class="std std-ref">zeModuleDynamicLink</span></a>. Modules cannot have ambiguous import dependencies, i.e., imported functions and global variables must only be defined once in any given set of modules passed to <a class="reference internal" href="api.html#zemoduledynamiclink"><span class="std std-ref">zeModuleDynamicLink</span></a>. Imports are linked only once. Once all the import dependencies of a module have been linked, the use of that fully import-linked module in subsequent calls to <a class="reference internal" href="api.html#zemoduledynamiclink"><span class="std std-ref">zeModuleDynamicLink</span></a> will not cause the imports of the module to be re-linked.</p>
<p>The <a class="reference internal" href="api.html#zemoduledynamiclink"><span class="std std-ref">zeModuleDynamicLink</span></a> function can optionally generate a link log object ze_module_build_log_handle_t.</p>
<pre class="literal-block">...
ze_module_build_log_handle_t linklog;
<a class="reference internal" href="api.html#ze-result-t"><span class="std std-ref">ze_result_t</span></a> result = <a class="reference internal" href="api.html#zemoduledynamiclink"><span class="std std-ref">zeModuleDynamicLink</span></a>(numModules, &amp;hModules, &amp;hLinklog);

// Check if there are linking errors
if (result == <a class="reference internal" href="api.html#ze-result-t"><span class="std std-ref">ZE_RESULT_ERROR_MODULE_LINK_FAILURE</span></a>) {
  size_t szLog = 0;
  <a class="reference internal" href="api.html#zemodulebuildloggetstring"><span class="std std-ref">zeModuleBuildLogGetString</span></a>(linklog, &amp;szLog, nullptr);

  char_t* strLog = allocate(szLog);
  <a class="reference internal" href="api.html#zemodulebuildloggetstring"><span class="std std-ref">zeModuleBuildLogGetString</span></a>(linklog, &amp;szLog, strLog);

  // Save log to disk.
  ...

  free(strLog);
}

<a class="reference internal" href="api.html#zemodulebuildlogdestroy"><span class="std std-ref">zeModuleBuildLogDestroy</span></a>(linklog);</pre>
</section>
<section id="module-caching-with-native-binaries">
<h4>Module Caching with Native Binaries<a class="headerlink" href="#module-caching-with-native-binaries" title="Link to this heading">#</a></h4>
<p>Disk caching of modules is not supported by the driver. If a disk cache for modules is desired, then it is the
responsibility of the application to implement this using <a class="reference internal" href="api.html#zemodulegetnativebinary"><span class="std std-ref">zeModuleGetNativeBinary</span></a>.</p>
<pre class="literal-block">...
// compute hash for pIL and check cache.
...

if (cacheUpdateNeeded)
{
    size_t szBinary = 0;
    <a class="reference internal" href="api.html#zemodulegetnativebinary"><span class="std std-ref">zeModuleGetNativeBinary</span></a>(hModule, &amp;szBinary, nullptr);

    uint8_t* pBinary = allocate(szBinary);
    <a class="reference internal" href="api.html#zemodulegetnativebinary"><span class="std std-ref">zeModuleGetNativeBinary</span></a>(hModule, &amp;szBinary, pBinary);

    // cache pBinary for corresponding IL
    ...

    free(pBinary);
}</pre>
<p>Also, note that the native binary will retain all debug information that is associated with the module. This allows debug
capabilities for modules that are created from native binaries.</p>
</section>
<section id="built-in-kernels">
<h4>Built-in Kernels<a class="headerlink" href="#built-in-kernels" title="Link to this heading">#</a></h4>
<p>Built-in kernels are not supported but can be implemented by an upper level runtime or library using the native binary
interface.</p>
</section>
</section>
<section id="kernels">
<span id="id7"></span><h3>Kernels<a class="headerlink" href="#kernels" title="Link to this heading">#</a></h3>
<p>A Kernel is a reference to a kernel within a module and it supports both explicit and implicit kernel
arguments along with data needed for launch.</p>
<p>The following pseudo-code demonstrates a sequence for creating a kernel from a module:</p>
<pre class="literal-block"><a class="reference internal" href="api.html#ze-kernel-desc-t"><span class="std std-ref">ze_kernel_desc_t</span></a> kernelDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_KERNEL_DESC</span></a>,
    nullptr,
    0, // flags
    &quot;image_scaling&quot;
};
ze_kernel_handle_t hKernel;
<a class="reference internal" href="api.html#ze-result-t"><span class="std std-ref">ze_result_t</span></a> result = <a class="reference internal" href="api.html#zekernelcreate"><span class="std std-ref">zeKernelCreate</span></a>(hModule, &amp;kernelDesc, &amp;hKernel);

// Check if there are unresolved imports
if (result == <a class="reference internal" href="api.html#ze-result-t"><span class="std std-ref">ZE_RESULT_ERROR_INVALID_MODULE_UNLINKED</span></a>) {
   // Un-resolvable import dependencies found in module!
   ...
}

// Check to see if the kernel &quot;image_scaling&quot; was found in the supplied module
if (result == <a class="reference internal" href="api.html#ze-result-t"><span class="std std-ref">ZE_RESULT_ERROR_INVALID_KERNEL_NAME</span></a>) {
   // Kernel &quot;image_scaling&quot; not found in module!
   ...
}

...</pre>
<section id="kernel-properties">
<h4>Kernel Properties<a class="headerlink" href="#kernel-properties" title="Link to this heading">#</a></h4>
<p>Use <a class="reference internal" href="api.html#zekernelgetproperties"><span class="std std-ref">zeKernelGetProperties</span></a> to query invariant properties from a Kernel object.</p>
<pre class="literal-block">...
<a class="reference internal" href="api.html#ze-kernel-properties-t"><span class="std std-ref">ze_kernel_properties_t</span></a> kernelProperties;
<a class="reference internal" href="api.html#zekernelgetproperties"><span class="std std-ref">zeKernelGetProperties</span></a>(hKernel, &amp;kernelProperties);
...</pre>
<p>See <a class="reference internal" href="api.html#ze-kernel-properties-t"><span class="std std-ref">ze_kernel_properties_t</span></a> for more information for kernel properties.</p>
</section>
</section>
<section id="execution-1">
<span id="id8"></span><h3>Execution<a class="headerlink" href="#execution-1" title="Link to this heading">#</a></h3>
<section id="kernel-group-size">
<h4>Kernel Group Size<a class="headerlink" href="#kernel-group-size" title="Link to this heading">#</a></h4>
<p>The group size for a kernel can be set using <a class="reference internal" href="api.html#zekernelsetgroupsize"><span class="std std-ref">zeKernelSetGroupSize</span></a>. If a group size is not
set prior to appending a kernel into a command list then a default will be chosen.
The group size can be updated over a series of append operations. The driver will copy the
group size information when appending the kernel into the command list.</p>
<pre class="literal-block"><a class="reference internal" href="api.html#zekernelsetgroupsize"><span class="std std-ref">zeKernelSetGroupSize</span></a>(hKernel, groupSizeX, groupSizeY, 1);

...</pre>
<p>The API supports a query for suggested group size when providing the global size. This function ignores the
group size that was set on the kernel using <a class="reference internal" href="api.html#zekernelsetgroupsize"><span class="std std-ref">zeKernelSetGroupSize</span></a>.</p>
<pre class="literal-block">// Find suggested group size for processing image.
uint32_t groupSizeX;
uint32_t groupSizeY;
<a class="reference internal" href="api.html#zekernelsuggestgroupsize"><span class="std std-ref">zeKernelSuggestGroupSize</span></a>(hKernel, imageWidth, imageHeight, 1, &amp;groupSizeX, &amp;groupSizeY, nullptr);

<a class="reference internal" href="api.html#zekernelsetgroupsize"><span class="std std-ref">zeKernelSetGroupSize</span></a>(hKernel, groupSizeX, groupSizeY, 1);

...</pre>
</section>
<section id="kernel-arguments">
<h4>Kernel Arguments<a class="headerlink" href="#kernel-arguments" title="Link to this heading">#</a></h4>
<p>Kernel arguments represent only the explicit kernel arguments that are within brackets e.g. func(arg1, arg2, …).</p>
<ul class="simple">
<li><p>Use <a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a> to setup arguments for a kernel launch.</p></li>
<li><p>The <a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a> et al. functions will make a copy of the kernel arguments to send to the device.</p></li>
<li><p>Kernel arguments can be updated at any time and used across multiple append calls.</p></li>
</ul>
<p>The following pseudo-code demonstrates a sequence for setting kernel arguments and launching the kernel:</p>
<pre class="literal-block">// Bind arguments
<a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a>(hKernel, 0, sizeof(ze_image_handle_t), &amp;src_image);
<a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a>(hKernel, 1, sizeof(ze_image_handle_t), &amp;dest_image);
<a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a>(hKernel, 2, sizeof(uint32_t), &amp;width);
<a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a>(hKernel, 3, sizeof(uint32_t), &amp;height);

<a class="reference internal" href="api.html#ze-group-count-t"><span class="std std-ref">ze_group_count_t</span></a> launchArgs = { numGroupsX, numGroupsY, 1 };

// Append launch kernel
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);

// Update image pointers to copy and scale next image.
<a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a>(hKernel, 0, sizeof(ze_image_handle_t), &amp;src2_image);
<a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a>(hKernel, 1, sizeof(ze_image_handle_t), &amp;dest2_image);

// Append launch kernel
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);

...</pre>
</section>
<section id="kernel-launch">
<h4>Kernel Launch<a class="headerlink" href="#kernel-launch" title="Link to this heading">#</a></h4>
<p>In order to launch a kernel on the device an application must call one of the AppendLaunchKernel-style functions for
a command list. The most basic version of these is <a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a> which takes a
command list, kernel handle, launch arguments, and an optional synchronization event used to signal completion.
The launch arguments contain thread group dimensions.</p>
<pre class="literal-block">// compute number of groups to launch based on image size and group size.
uint32_t numGroupsX = imageWidth / groupSizeX;
uint32_t numGroupsY = imageHeight / groupSizeY;

<a class="reference internal" href="api.html#ze-group-count-t"><span class="std std-ref">ze_group_count_t</span></a> launchArgs = { numGroupsX, numGroupsY, 1 };

// Append launch kernel
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);</pre>
<p>The function <a class="reference internal" href="api.html#zecommandlistappendlaunchkernelindirect"><span class="std std-ref">zeCommandListAppendLaunchKernelIndirect</span></a> allows the launch parameters to be supplied indirectly in a
buffer that the device reads instead of the command itself. This allows for the previous operations on the
device to generate the parameters.</p>
<pre class="literal-block"><a class="reference internal" href="api.html#ze-group-count-t"><span class="std std-ref">ze_group_count_t</span></a>* pIndirectArgs;

...
<a class="reference internal" href="api.html#zememallocdevice"><span class="std std-ref">zeMemAllocDevice</span></a>(hContext, &amp;desc, sizeof(<a class="reference internal" href="api.html#ze-group-count-t"><span class="std std-ref">ze_group_count_t</span></a>), sizeof(uint32_t), hDevice, &amp;pIndirectArgs);

// Append launch kernel - indirect
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernelindirect"><span class="std std-ref">zeCommandListAppendLaunchKernelIndirect</span></a>(hCommandList, hKernel, &amp;pIndirectArgs, nullptr, 0, nullptr);</pre>
</section>
<section id="cooperative-kernels">
<h4>Cooperative Kernels<a class="headerlink" href="#cooperative-kernels" title="Link to this heading">#</a></h4>
<p>Cooperative kernels allow sharing of data and synchronization across all launched groups in a safe manner. To support this
there is a <a class="reference internal" href="api.html#zecommandlistappendlaunchcooperativekernel"><span class="std std-ref">zeCommandListAppendLaunchCooperativeKernel</span></a> that allows launching groups that can cooperate with each other.
The command list must be submitted to a command queue that was created with an ordinal of a command queue group
that has the <a class="reference internal" href="api.html#ze-command-queue-group-property-flags-t"><span class="std std-ref">ZE_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COOPERATIVE_KERNELS</span></a> flags set. The maximum number of groups for a
cooperative kernel launch may be determined by calling <a class="reference internal" href="api.html#zekernelsuggestmaxcooperativegroupcount"><span class="std std-ref">zeKernelSuggestMaxCooperativeGroupCount</span></a>.</p>
<pre class="literal-block">// query the maximum cooperative kernel launch for the kernel
uint32_t maxGroupCount;
<a class="reference internal" href="api.html#zekernelsuggestmaxcooperativegroupcount"><span class="std std-ref">zeKernelSuggestMaxCooperativeGroupCount</span></a>(hKernel, &amp;maxGroupCount);

// the total group count must be smaller than the queried maximum
assert(numGroupsX * numGroupsY * numGroupsZ &lt; maxGroupCount);

<a class="reference internal" href="api.html#ze-group-count-t"><span class="std std-ref">ze_group_count_t</span></a> launchArgs = { numGroupsX, numGroupsY, numGroupsZ };

// Append launch cooperative kernel
<a class="reference internal" href="api.html#zecommandlistappendlaunchcooperativekernel"><span class="std std-ref">zeCommandListAppendLaunchCooperativeKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);</pre>
</section>
</section>
<section id="sampler">
<h3>Sampler<a class="headerlink" href="#sampler" title="Link to this heading">#</a></h3>
<p>The API supports Sampler objects that represent state needed for sampling images from within
kernels. The <a class="reference internal" href="api.html#zesamplercreate"><span class="std std-ref">zeSamplerCreate</span></a> function takes a sampler descriptor (<a class="reference internal" href="api.html#ze-sampler-desc-t"><span class="std std-ref">ze_sampler_desc_t</span></a>):</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Sampler Field</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Address Mode</p></td>
<td><p>Determines how out-of-bounds
accesses are handled. See
<a class="reference internal" href="api.html#ze-sampler-address-mode-t"><span class="std std-ref">ze_sampler_address_mode_t</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p>Filter Mode</p></td>
<td><p>Specifies which filtering mode to
use. See
<a class="reference internal" href="api.html#ze-sampler-filter-mode-t"><span class="std std-ref">ze_sampler_filter_mode_t</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p>Normalized</p></td>
<td><p>Specifies whether coordinates for
addressing image are normalized
[0,1] or not.</p></td>
</tr>
</tbody>
</table>
<p>The following pseudo-code demonstrates the creation of a sampler object and passing it as a kernel argument:</p>
<pre class="literal-block">// Setup sampler for linear filtering and clamp out of bounds accesses to edge.
<a class="reference internal" href="api.html#ze-sampler-desc-t"><span class="std std-ref">ze_sampler_desc_t</span></a> desc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_SAMPLER_DESC</span></a>,
    nullptr,
    <a class="reference internal" href="api.html#ze-sampler-address-mode-t"><span class="std std-ref">ZE_SAMPLER_ADDRESS_MODE_CLAMP</span></a>,
    <a class="reference internal" href="api.html#ze-sampler-filter-mode-t"><span class="std std-ref">ZE_SAMPLER_FILTER_MODE_LINEAR</span></a>,
    false
    };
ze_sampler_handle_t sampler;
<a class="reference internal" href="api.html#zesamplercreate"><span class="std std-ref">zeSamplerCreate</span></a>(hContext, hDevice, &amp;desc, &amp;sampler);
...

// The sampler can be passed as a kernel argument.
<a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a>(hKernel, 0, sizeof(ze_sampler_handle_t), &amp;sampler);

// Append launch kernel
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);</pre>
</section>
<section id="formatted-output">
<h3>Formatted Output<a class="headerlink" href="#formatted-output" title="Link to this heading">#</a></h3>
<p>The API supports the ability to print formatted output from a kernel using functions such as <code class="docutils literal notranslate"><span class="pre">printf</span></code>.
Calls to print formatted output will cause data to be written to an internal buffer, where the size of the internal buffer is given by <a class="reference internal" href="api.html#ze-device-module-properties-t"><span class="std std-ref">ze_device_module_properties_t</span></a>.printfBufferSize.
When the internal buffer becomes full, additional calls to print formatted output will return an error code.</p>
<p>There is no ordering guarantee for the formatted output.
If multiple work-items make multiple calls to <code class="docutils literal notranslate"><span class="pre">printf</span></code>, the output from one work-item may appear intermixed with output from other work-items.</p>
<p>On some devices, the internal buffer may not contain the formatted output itself, and instead the formatting may occur on the host.
Additionally, the final formatting may not occur and the output may not be flushed to the output stream until the event associated with the kernel launch is complete.
To ensure all output has been flushed to the output stream, wait on the event associated with the kernel launch, or wait for the kernel launch to complete using a coarser-grained synchronization method such as <a class="reference internal" href="api.html#zefencehostsynchronize"><span class="std std-ref">zeFenceHostSynchronize</span></a> or <a class="reference internal" href="api.html#zecommandqueuesynchronize"><span class="std std-ref">zeCommandQueueSynchronize</span></a>.</p>
</section>
</section>
<section id="advanced">
<h2>Advanced<a class="headerlink" href="#advanced" title="Link to this heading">#</a></h2>
<section id="environment-variables">
<h3>Environment Variables<a class="headerlink" href="#environment-variables" title="Link to this heading">#</a></h3>
<p>The following table documents the supported knobs for overriding default functional behavior.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Category</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Values</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td rowspan="3"><p>Device</p></td>
<td><p>ZE_FLAT_DEVICE_HIERARCHY</p></td>
<td><p>{<strong>COMPOSITE</strong>, FLAT, COMBINED}</p></td>
<td><p>Defines device hierarchy model exposed by Level Zero driver implementation</p></td>
</tr>
<tr class="row-odd"><td><p>ZE_AFFINITY_MASK</p></td>
<td><p>list</p></td>
<td><p>Forces driver to only report devices (and sub-devices) as specified by values</p></td>
</tr>
<tr class="row-even"><td><p>ZE_ENABLE_PCI_ID_DEVICE_ORDER</p></td>
<td><p>{<strong>0</strong>, 1}</p></td>
<td><p>Forces driver to report devices from lowest to highest PCI bus ID</p></td>
</tr>
<tr class="row-odd"><td><p>Memory</p></td>
<td><p>ZE_SHARED_FORCE_DEVICE_ALLOC</p></td>
<td><p>{<strong>0</strong>, 1}</p></td>
<td><p>Forces all shared allocations into device memory</p></td>
</tr>
</tbody>
</table>
<section id="device-hierarchy">
<h4>Device Hierarchy<a class="headerlink" href="#device-hierarchy" title="Link to this heading">#</a></h4>
<p>ZE_FLAT_DEVICE_HIERARCHY allows users to select the device hierarchy model with which the underlying hardware is exposed and the types of devices returned with <a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a>.</p>
<p>When setting to <cite>COMPOSITE</cite>, <a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a> returns all the devices that do not have a root-device. Traversing the device hierarchy is possible by querying sub-devices with <a class="reference internal" href="api.html#zedevicegetsubdevices"><span class="std std-ref">zeDeviceGetSubDevices</span></a> and root-devices with <a class="reference internal" href="api.html#zedevicegetrootdevice"><span class="std std-ref">zeDeviceGetRootDevice</span></a>. Driver implementation may perform implicit optimizations to submissions and allocations done in the root-devices.</p>
<p>When setting to <cite>FLAT</cite>, <a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a> returns all the devices that do not have sub-devices. Traversing the device hierarchy is <strong>not</strong> possible, with <a class="reference internal" href="api.html#zedevicegetsubdevices"><span class="std std-ref">zeDeviceGetSubDevices</span></a> returning always a count of 0 device handles and <a class="reference internal" href="api.html#zedevicegetrootdevice"><span class="std std-ref">zeDeviceGetRootDevice</span></a> returning nullptr. This mode allows Level Zero driver implementations to optimize execution and memory allocations by removing any overhead required to account for simultaneous use of root-devices and sub-devices in the same application.</p>
<p>When setting to <cite>COMBINED</cite>, <a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a> returns all the devices that do not have sub-devices. Traversing the device hierarchy is possible by querying sub-devices with <a class="reference internal" href="api.html#zedevicegetsubdevices"><span class="std std-ref">zeDeviceGetSubDevices</span></a> and root-devices with <a class="reference internal" href="api.html#zedevicegetrootdevice"><span class="std std-ref">zeDeviceGetRootDevice</span></a>. Driver implementation may perform implicit optimizations to submissions and allocations done in the root-devices.</p>
<p>Devices returned by SYSMAN APIs are not affected by ZE_FLAT_DEVICE_HIERARCHY and always return the top-level device handles corresponding to the physical devices.</p>
</section>
<section id="affinity-mask">
<h4>Affinity Mask<a class="headerlink" href="#affinity-mask" title="Link to this heading">#</a></h4>
<p>The affinity mask allows an application or tool to restrict which devices, and sub-devices, are visible to 3rd-party libraries or applications in another process, respectively.
The affinity mask affects the number of handles returned from <a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a> and <a class="reference internal" href="api.html#zedevicegetsubdevices"><span class="std std-ref">zeDeviceGetSubDevices</span></a>.
The affinity mask is specified via an environment variable as a comma-seperated list of device and/or subdevice ordinals.
The values are specific to system configuration; e.g., the number of devices and the number of sub-devices for each device.
The values are specific to the order in which devices are reported by the driver; i.e., the first device maps to ordinal 0, the second device to ordinal 1, and so forth.
If the affinity mask is not set, then all devices and sub-devices are reported; as is the default behavior.</p>
<p>The affinity mask masks the devices as defined by value set in the ZE_FLAT_DEVICE_HIERARCHY environment variable, i.e., a Level Zero driver shall read
first ZE_FLAT_DEVICE_HIERARCHY to determine the device handles to be used by the application and then interpret the values passed in ZE_AFFINITY_MASK
based on the device model selected.</p>
<p>The order of the devices reported by the <a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a> is implementation-specific and not affected by the order of devices in the affinity mask.</p>
<p>The order of the devices reported by the <a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a> can be forced to be consistent by setting the ZE_ENABLE_PCI_ID_DEVICE_ORDER environment variable.</p>
<p>The following examples demonstrate proper usage for a system configuration composed of two physical devices, each of which can be further
sub-divided into four smaller devices. For the purpose of these examples, we will refer to the two physical devices as <cite>parent devices</cite>
and to the smaller sub-devices as <cite>tiles</cite>.</p>
<p>When setting the ZE_AFFINITY_MASK with different values, and ZE_FLAT_DEVICE_HIERARCHY to <cite>COMPOSITE</cite>, the following scenarios may occur:</p>
<p>ZE_AFFINITY_MASK = <cite>0, 1</cite>: all parent devices and tiles are reported (same as default):</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Parent Device</p></th>
<th class="head"><p>Tile</p></th>
<th class="head"><p>Exposed</p></th>
<th class="head"><p>Device Handle Used</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0, sub-device handle 0</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0, sub-device handle 1</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>2</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0, sub-device handle 2</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>3</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0, sub-device handle 3</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 1, sub-device handle 0</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 1, sub-device handle 1</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 1, sub-device handle 2</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>3</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 1, sub-device handle 3</p></td>
</tr>
</tbody>
</table>
<p>ZE_AFFINITY_MASK = <cite>0</cite>: only parent device 0 is reported as device handle 0, with all its tiles reported as sub-device handles:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Parent Device</p></th>
<th class="head"><p>Tile</p></th>
<th class="head"><p>Exposed</p></th>
<th class="head"><p>Device Handle Used</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0, sub-device handle 0</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0, sub-device handle 1</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>2</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0, sub-device handle 2</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>3</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0, sub-device handle 3</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>3</p></td>
<td><p>No</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>ZE_AFFINITY_MASK = <cite>1</cite>: only parent device 1 is reported as device handle 0, with all its tiles reported as sub-device handles:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Parent Device</p></th>
<th class="head"><p>Tile</p></th>
<th class="head"><p>Exposed</p></th>
<th class="head"><p>Device Handle Used</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>2</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>3</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0, sub-device handle 0</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0, sub-device handle 1</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0, sub-device handle 2</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>3</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0, sub-device handle 3</p></td>
</tr>
</tbody>
</table>
<p>ZE_AFFINITY_MASK = <cite>0.0</cite>: only tile 0 in parent device 0 is reported as device handle 0:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Parent Device</p></th>
<th class="head"><p>Tile</p></th>
<th class="head"><p>Exposed</p></th>
<th class="head"><p>Device Handle Used</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>2</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>3</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>3</p></td>
<td><p>No</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>ZE_AFFINITY_MASK = <cite>1.1, 1.2</cite>: only parent device 1 is reported as device handle 0; with its tiles 1 and 2 reported as its sub-devices 0 and 1, respectively:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Parent Device</p></th>
<th class="head"><p>Tile</p></th>
<th class="head"><p>Exposed</p></th>
<th class="head"><p>Device Handle Used</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>2</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>3</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0, sub-device handle 0</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0, sub-device handle 1</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>3</p></td>
<td><p>No</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>ZE_AFFINITY_MASK = <cite>0.2, 1.3, 1.0, 0.3</cite>: both parent devices 0 and 1 are reported as device handles 0 and 1, respectively; parent device 0 reports its tiles 2 and 3 as sub-devices 0 and 1, respectively; parent device 1 reports tiles 0 and 3 as sub-devices 0 and 1, respectively; the order is unchanged:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Parent Device</p></th>
<th class="head"><p>Tile</p></th>
<th class="head"><p>Exposed</p></th>
<th class="head"><p>Device Handle Used</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>2</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0, sub-device handle 0</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>3</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0, sub-device handle 1</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 1, sub-device handle 0</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>3</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 1, sub-device handle 1</p></td>
</tr>
</tbody>
</table>
<p>The following examples show the use of different values in the ZE_AFFINITY_MASK when setting ZE_FLAT_DEVICE_HIERARCHY to <cite>FLAT</cite>, in the
same system with two parent devices and four tiles each. When setting ZE_FLAT_DEVICE_HIERARCHY to <cite>FLAT</cite>, only the tiles are reported by
<a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a>, which means that in this system <a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a> would report up to 8 device handles, with device handles 0 to 3 corresponding
to the four tiles in parent device 0, and device handles 4 to 7 corresponding to the four tiles in parent device 1:</p>
<p>ZE_AFFINITY_MASK = <cite>0, 1, 2, 3, 4, 5, 6, 7</cite>: all tiles are reported as device handles by <a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a> (same as default):</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Parent Device</p></th>
<th class="head"><p>Tile</p></th>
<th class="head"><p>Exposed</p></th>
<th class="head"><p>Device Handle Used</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 1</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>2</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 2</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>3</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 3</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 4</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 5</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 6</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>3</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 7</p></td>
</tr>
</tbody>
</table>
<p>ZE_AFFINITY_MASK = <cite>0</cite>: only tile 0 in parent device 0 is reported as device handle 0:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Parent Device</p></th>
<th class="head"><p>Tile</p></th>
<th class="head"><p>Exposed</p></th>
<th class="head"><p>Device Handle Used</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>2</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>3</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>3</p></td>
<td><p>No</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>ZE_AFFINITY_MASK = <cite>1</cite>: only tile 1 in parent device 0 is reported as device handle 0.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Parent Device</p></th>
<th class="head"><p>Tile</p></th>
<th class="head"><p>Exposed</p></th>
<th class="head"><p>Device Handle Used</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>2</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>3</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>3</p></td>
<td><p>No</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>ZE_AFFINITY_MASK = <cite>0, 4</cite>: tile 0 from parent device 0 is reported as device handle 0 and tile 0 in parent device 1 is reported as device handle 1:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Parent Device</p></th>
<th class="head"><p>Tile</p></th>
<th class="head"><p>Exposed</p></th>
<th class="head"><p>Device Handle Used</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>2</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>3</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 1</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>3</p></td>
<td><p>No</p></td>
<td></td>
</tr>
</tbody>
</table>
<p>ZE_AFFINITY_MASK = <cite>1, 2, 7</cite>: tile 1 from parent device 0 is reported as device handle 0, tile 2 in parent device 0 is reported as device handle 1, and tile 3 in parent device 1 is reported as device handle 2:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Parent Device</p></th>
<th class="head"><p>Tile</p></th>
<th class="head"><p>Exposed</p></th>
<th class="head"><p>Device Handle Used</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 0</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>2</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 1</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>3</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>No</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>3</p></td>
<td><p>Yes</p></td>
<td><p>Device handle 2</p></td>
</tr>
</tbody>
</table>
<p>ZE_AFFINITY_MASK = <cite>0.0</cite>: is not valid, as with ZE_FLAT_DEVICE_HIERARCHY set to <cite>FLAT</cite>, the device handles reported by <a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a> are those which do not contain further sub-devices.</p>
</section>
</section>
<section id="sub-device-support">
<h3>Sub-Device Support<a class="headerlink" href="#sub-device-support" title="Link to this heading">#</a></h3>
<p>The API allows support for sub-devices which can enable finer-grained control of scheduling and memory allocation to a sub-partition of the device.
There are functions to query and obtain sub-devices, but outside of these functions there are no distinctions between sub-devices and devices.
Sub-devices are not required to represent unique partitions of a device; i.e. multiple sub-devices may share the same physical hardware.
Furthermore, a sub-device can be partitioned into more sub-devices; e.g. down to a single slice.</p>
<p>Use <a class="reference internal" href="api.html#zedevicegetsubdevices"><span class="std std-ref">zeDeviceGetSubDevices</span></a> to confirm sub-devices are supported and to obtain a sub-device handle.
There are additional device properties in <a class="reference internal" href="api.html#ze-device-properties-t"><span class="std std-ref">ze_device_properties_t</span></a> for sub-devices.
These can be used to confirm a device is a sub-device and to query the sub-device id.
This may be used by libraries to determine if an input device handle represents a device or sub-device.</p>
<p>A driver is required to make device memory allocations on the parent device visible to its sub-devices.
However, when using a sub-device handle, the driver will attempt to place any device memory allocations in the local memory that is attached to the sub-device.
These allocations are only visible to the sub-device, its sub-devices, and so forth.
If the API call returns <a class="reference internal" href="api.html#ze-result-t"><span class="std std-ref">ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY</span></a>, then the application may attempt to retry using the parent device.</p>
<p>When creating command queues for a sub-device,
the application must determine the ordinal from calling <a class="reference internal" href="api.html#zedevicegetcommandqueuegroupproperties"><span class="std std-ref">zeDeviceGetCommandQueueGroupProperties</span></a> using the sub-device handle.
See <a class="reference internal" href="api.html#ze-command-queue-desc-t"><span class="std std-ref">ze_command_queue_desc_t</span></a> for more details.</p>
<p>A 16-byte unique device identifier (uuid) can be obtained for a device
or sub-device using <a class="reference internal" href="api.html#zedevicegetproperties"><span class="std std-ref">zeDeviceGetProperties</span></a>.</p>
<pre class="literal-block">// Query for all sub-devices of the device
uint32_t subdeviceCount = 0;
<a class="reference internal" href="api.html#zedevicegetsubdevices"><span class="std std-ref">zeDeviceGetSubDevices</span></a>(hDevice, &amp;subdeviceCount, nullptr);

ze_device_handle_t* allSubDevices = allocate(subdeviceCount * sizeof(ze_device_handle_t));
<a class="reference internal" href="api.html#zedevicegetsubdevices"><span class="std std-ref">zeDeviceGetSubDevices</span></a>(hDevice, &amp;subdeviceCount, &amp;allSubDevices);

// Desire is to allocate and dispatch work to sub-device 2.
assert(subdeviceCount &gt;= 3);
ze_device_handle_t hSubdevice = allSubDevices[2];

// Query sub-device properties.
<a class="reference internal" href="api.html#ze-device-properties-t"><span class="std std-ref">ze_device_properties_t</span></a> subdeviceProps {};
subDeviceProps.stype = <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES</span></a>;
<a class="reference internal" href="api.html#zedevicegetproperties"><span class="std std-ref">zeDeviceGetProperties</span></a>(hSubdevice, &amp;subdeviceProps);

assert(subdeviceProps.flags &amp; <a class="reference internal" href="api.html#ze-device-property-flags-t"><span class="std std-ref">ZE_DEVICE_PROPERTY_FLAG_SUBDEVICE</span></a>); // Ensure that we have a handle to a sub-device.
assert(subdeviceProps.subdeviceId == 2);    // Ensure that we have a handle to the sub-device we asked for.

void* pMemForSubDevice2;
<a class="reference internal" href="api.html#zememallocdevice"><span class="std std-ref">zeMemAllocDevice</span></a>(hContext, &amp;desc, memSize, sizeof(uint32_t), hSubdevice, &amp;pMemForSubDevice2);
...</pre>
</section>
<section id="device-residency">
<h3>Device Residency<a class="headerlink" href="#device-residency" title="Link to this heading">#</a></h3>
<p>For devices that do not support page-faults, the driver must ensure that all pages that will be accessed by the kernel are resident before program execution.
This can be determined by checking <a class="reference internal" href="api.html#ze-device-properties-t"><span class="std std-ref">ze_device_properties_t</span></a>.flags for <a class="reference internal" href="api.html#ze-device-property-flags-t"><span class="std std-ref">ZE_DEVICE_PROPERTY_FLAG_ONDEMANDPAGING</span></a>.</p>
<p>In most cases, the driver implicitly handles residency of allocations for device access.
This can be done by inspecting API parameters, including kernel arguments.
However, in cases where the devices does <strong>not</strong> support page-faulting <em>and</em> the driver is incapable of determining whether an allocation will be accessed by the device,
such as multiple levels of indirection, there are two methods available:</p>
<ol class="arabic">
<li><p>The application may set the <a class="reference internal" href="api.html#ze-kernel-flags-t"><span class="std std-ref">ZE_KERNEL_FLAG_FORCE_RESIDENCY</span></a> flag during program creation to force all device allocations to be resident during execution.</p>
<blockquote>
<div><ul>
<li><p>The application should specify which allocation types will be indirectly accessed, using <a class="reference internal" href="api.html#zekernelsetindirectaccess"><span class="std std-ref">zeKernelSetIndirectAccess</span></a> and the following flags, to optimize which allocations are made resident.</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="api.html#ze-kernel-indirect-access-flags-t"><span class="std std-ref">ZE_KERNEL_INDIRECT_ACCESS_FLAG_HOST</span></a></p></li>
<li><p><a class="reference internal" href="api.html#ze-kernel-indirect-access-flags-t"><span class="std std-ref">ZE_KERNEL_INDIRECT_ACCESS_FLAG_DEVICE</span></a></p></li>
<li><p><a class="reference internal" href="api.html#ze-kernel-indirect-access-flags-t"><span class="std std-ref">ZE_KERNEL_INDIRECT_ACCESS_FLAG_SHARED</span></a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>If the driver is unable to make all allocations resident, then the call to <a class="reference internal" href="api.html#zecommandqueueexecutecommandlists"><span class="std std-ref">zeCommandQueueExecuteCommandLists</span></a> will return <a class="reference internal" href="api.html#ze-result-t"><span class="std std-ref">ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY</span></a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Explicit <a class="reference internal" href="api.html#zecontextmakememoryresident"><span class="std std-ref">zeContextMakeMemoryResident</span></a> APIs are included for the application to dynamically change residency as needed.</p>
<blockquote>
<div><ul class="simple">
<li><p>If the application over-commits device memory, then a call to <a class="reference internal" href="api.html#zecontextmakememoryresident"><span class="std std-ref">zeContextMakeMemoryResident</span></a> will return <a class="reference internal" href="api.html#ze-result-t"><span class="std std-ref">ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY</span></a></p></li>
</ul>
</div></blockquote>
</li>
</ol>
<p>If the application does not properly manage residency for these cases then the device may experience unrecoverable page-faults.</p>
<p>The following pseudo-code demonstrates a sequence for using coarse-grain residency control for indirect arguments:</p>
<pre class="literal-block">struct node {
    node* next;
};
node* begin = nullptr;
<a class="reference internal" href="api.html#zememallochost"><span class="std std-ref">zeMemAllocHost</span></a>(hContext, &amp;desc, sizeof(node), 1, &amp;begin);
<a class="reference internal" href="api.html#zememallochost"><span class="std std-ref">zeMemAllocHost</span></a>(hContext, &amp;desc, sizeof(node), 1, &amp;begin-&gt;next);
<a class="reference internal" href="api.html#zememallochost"><span class="std std-ref">zeMemAllocHost</span></a>(hContext, &amp;desc, sizeof(node), 1, &amp;begin-&gt;next-&gt;next);

// 'begin' is passed as kernel argument and appended into command list
<a class="reference internal" href="api.html#zekernelsetindirectaccess"><span class="std std-ref">zeKernelSetIndirectAccess</span></a>(hKernel, <a class="reference internal" href="api.html#ze-kernel-indirect-access-flags-t"><span class="std std-ref">ZE_KERNEL_INDIRECT_ACCESS_FLAG_HOST</span></a>);
<a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a>(hKernel, 0, sizeof(node*), &amp;begin);
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);

...

<a class="reference internal" href="api.html#zecommandqueueexecutecommandlists"><span class="std std-ref">zeCommandQueueExecuteCommandLists</span></a>(hCommandQueue, 1, &amp;hCommandList, nullptr);
...</pre>
<p>The following pseudo-code demonstrates a sequence for using fine-grain residency control for indirect arguments:</p>
<pre class="literal-block">struct node {
    node* next;
};
node* begin = nullptr;
<a class="reference internal" href="api.html#zememallochost"><span class="std std-ref">zeMemAllocHost</span></a>(hContext, &amp;desc, sizeof(node), 1, &amp;begin);
<a class="reference internal" href="api.html#zememallochost"><span class="std std-ref">zeMemAllocHost</span></a>(hContext, &amp;desc, sizeof(node), 1, &amp;begin-&gt;next);
<a class="reference internal" href="api.html#zememallochost"><span class="std std-ref">zeMemAllocHost</span></a>(hContext, &amp;desc, sizeof(node), 1, &amp;begin-&gt;next-&gt;next);

// 'begin' is passed as kernel argument and appended into command list
<a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a>(hKernel, 0, sizeof(node*), &amp;begin);
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);
...

// Make indirect allocations resident before enqueuing
<a class="reference internal" href="api.html#zecontextmakememoryresident"><span class="std std-ref">zeContextMakeMemoryResident</span></a>(hContext, hDevice, begin-&gt;next, sizeof(node));
<a class="reference internal" href="api.html#zecontextmakememoryresident"><span class="std std-ref">zeContextMakeMemoryResident</span></a>(hContext, hDevice, begin-&gt;next-&gt;next, sizeof(node));

<a class="reference internal" href="api.html#zecommandqueueexecutecommandlists"><span class="std std-ref">zeCommandQueueExecuteCommandLists</span></a>(hCommandQueue, 1, &amp;hCommandList, hFence);

// wait until complete
<a class="reference internal" href="api.html#zefencehostsynchronize"><span class="std std-ref">zeFenceHostSynchronize</span></a>(hFence, UINT32_MAX);

// Finally, evict to free device resources
<a class="reference internal" href="api.html#zecontextevictmemory"><span class="std std-ref">zeContextEvictMemory</span></a>(hContext, hDevice, begin-&gt;next, sizeof(node));
<a class="reference internal" href="api.html#zecontextevictmemory"><span class="std std-ref">zeContextEvictMemory</span></a>(hContext, hDevice, begin-&gt;next-&gt;next, sizeof(node));
...</pre>
</section>
<section id="interoperability-with-other-apis">
<h3>Interoperability with Other APIs<a class="headerlink" href="#interoperability-with-other-apis" title="Link to this heading">#</a></h3>
<p>Level-Zero includes general-purpose interoperability mechanisms for
memory allocations (both images and device memory) and modules.</p>
<p>Memory allocations may be shared between Level-Zero and other APIs via
<a class="reference internal" href="#external-memory"><span class="std std-ref">External Memory Import and Export</span></a>.
Level-Zero supports exporting memory allocations for use in other APIs
and importing memory allocations from other APIs.</p>
<p>Modules may be shared between Level-Zero and other APIs via native
format binaries, see <a class="reference internal" href="api.html#zemodulegetnativebinary"><span class="std std-ref">zeModuleGetNativeBinary</span></a> and <a class="reference internal" href="api.html#ze-module-format-t"><span class="std std-ref">ZE_MODULE_FORMAT_NATIVE</span></a>.</p>
<p>The following pseudo-code demonstrates interoperability with OpenCL <em>from</em> a OpenCL cl_program <em>to</em> a Level-Zero Kernel:</p>
<pre class="literal-block">void* clDeviceBinary;
size_t clDeviceBinarySize;
clGetProgramInfo(cl_program, CL_PROGRAM_BINARIES, clDeviceBinary, &amp;clDeviceBinarySize);

<a class="reference internal" href="api.html#ze-module-desc-t"><span class="std std-ref">ze_module_desc_t</span></a> desc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_MODULE_DESC</span></a>,
    nullptr,
    <a class="reference internal" href="api.html#ze-module-format-t"><span class="std std-ref">ZE_MODULE_FORMAT_NATIVE</span></a>,
    clDeviceBinarySize,
    clDeviceBinary
};
<a class="reference internal" href="api.html#zemodulecreate"><span class="std std-ref">zeModuleCreate</span></a>(hContext, hDevice, &amp;desc, &amp;hModule, nullptr);
<a class="reference internal" href="api.html#zekernelcreate"><span class="std std-ref">zeKernelCreate</span></a>(hModule, nullptr, hKernel); // same Kernel as OpenCL in Level-Zero</pre>
</section>
<section id="inter-process-communication">
<span id="id9"></span><h3>Inter-Process Communication<a class="headerlink" href="#inter-process-communication" title="Link to this heading">#</a></h3>
<p>The API allows sharing of memory objects across different device
processes. Since each process has its own virtual address space, there
is no guarantee that the same virtual address will be available when the
memory object is shared in new process. There are a set of APIs that
makes it easier to share the memory objects with ease.</p>
<p>There are two types of Inter-Process Communication (IPC) APIs for using
Level-Zero allocations across processes:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#memory-1"><span class="std std-ref">Memory</span></a></p></li>
<li><p><a class="reference internal" href="#events-1"><span class="std std-ref">Events</span></a></p></li>
</ol>
<section id="memory-1">
<span id="id10"></span><h4>Memory<a class="headerlink" href="#memory-1" title="Link to this heading">#</a></h4>
<p>The following code examples demonstrate how to use the memory IPC APIs:</p>
<ol class="arabic simple">
<li><p>First, the allocation is made, packaged, and sent on the sending
process:</p></li>
</ol>
<pre class="literal-block">void* dptr = nullptr;
<a class="reference internal" href="api.html#zememallocdevice"><span class="std std-ref">zeMemAllocDevice</span></a>(hContext, &amp;desc, size, alignment, hDevice, &amp;dptr);

<a class="reference internal" href="api.html#ze-ipc-mem-handle-t"><span class="std std-ref">ze_ipc_mem_handle_t</span></a> hIPC;
<a class="reference internal" href="api.html#zememgetipchandle"><span class="std std-ref">zeMemGetIpcHandle</span></a>(hContext, dptr, &amp;hIPC);

// Method of sending to receiving process is not defined by Level-Zero:
send_to_receiving_process(hIPC);</pre>
<ol class="arabic simple" start="2">
<li><p>Next, the allocation is received and un-packaged on the receiving
process:</p></li>
</ol>
<pre class="literal-block">// Method of receiving from sending process is not defined by Level-Zero:
<a class="reference internal" href="api.html#ze-ipc-mem-handle-t"><span class="std std-ref">ze_ipc_mem_handle_t</span></a> hIPC;
hIPC = receive_from_sending_process();

void* dptr = nullptr;
<a class="reference internal" href="api.html#zememopenipchandle"><span class="std std-ref">zeMemOpenIpcHandle</span></a>(hContext, hDevice, hIPC, 0, &amp;dptr);</pre>
<ol class="arabic simple" start="3">
<li><p>Each process may now refer to the same device memory allocation via its <code class="docutils literal notranslate"><span class="pre">dptr</span></code>.
Note, there is no guaranteed address equivalence for the values of <code class="docutils literal notranslate"><span class="pre">dptr</span></code> in each process.</p></li>
<li><p>To cleanup, first close the handle in the receiving process:</p></li>
</ol>
<pre class="literal-block"><a class="reference internal" href="api.html#zememcloseipchandle"><span class="std std-ref">zeMemCloseIpcHandle</span></a>(hContext, dptr);</pre>
<ol class="arabic simple" start="5">
<li><p>Finally, return the IPC handle to the driver with  <a class="reference internal" href="api.html#zememputipchandle"><span class="std std-ref">zeMemPutIpcHandle</span></a> and
free the device pointer in the sending process. If <a class="reference internal" href="api.html#zememputipchandle"><span class="std std-ref">zeMemPutIpcHandle</span></a> is not called,
any actions performed by that call are eventually done by <a class="reference internal" href="api.html#zememfree"><span class="std std-ref">zeMemFree</span></a>.</p></li>
</ol>
<pre class="literal-block"><a class="reference internal" href="api.html#zememputipchandle"><span class="std std-ref">zeMemPutIpcHandle</span></a>(hContext, hIpc);
<a class="reference internal" href="api.html#zememfree"><span class="std std-ref">zeMemFree</span></a>(hContext, dptr);</pre>
</section>
<section id="events-1">
<span id="id11"></span><h4>Events<a class="headerlink" href="#events-1" title="Link to this heading">#</a></h4>
<p>The following code examples demonstrate how to use the event IPC APIs:</p>
<ol class="arabic simple">
<li><p>First, the event pool is created, packaged, and sent on the sending process:</p></li>
</ol>
<pre class="literal-block">// create event pool
<a class="reference internal" href="api.html#ze-event-pool-desc-t"><span class="std std-ref">ze_event_pool_desc_t</span></a> eventPoolDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EVENT_POOL_DESC</span></a>,
    nullptr,
    <a class="reference internal" href="api.html#ze-event-pool-flags-t"><span class="std std-ref">ZE_EVENT_POOL_FLAG_IPC</span></a> | <a class="reference internal" href="api.html#ze-event-pool-flags-t"><span class="std std-ref">ZE_EVENT_POOL_FLAG_HOST_VISIBLE</span></a>,
    10 // count
};
ze_event_pool_handle_t hEventPool;
<a class="reference internal" href="api.html#zeeventpoolcreate"><span class="std std-ref">zeEventPoolCreate</span></a>(hContext, &amp;eventPoolDesc, 1, &amp;hDevice, &amp;hEventPool);

// get IPC handle and send to another process
<a class="reference internal" href="api.html#ze-ipc-event-pool-handle-t"><span class="std std-ref">ze_ipc_event_pool_handle_t</span></a> hIpcEvent;
<a class="reference internal" href="api.html#zeeventpoolgetipchandle"><span class="std std-ref">zeEventPoolGetIpcHandle</span></a>(hEventPool, &amp;hIpcEventPool);
send_to_receiving_process(hIpcEventPool);</pre>
<ol class="arabic simple" start="2">
<li><p>Next, the event pool is received and un-packaged on the receiving process:</p></li>
</ol>
<pre class="literal-block">// get IPC handle from other process
<a class="reference internal" href="api.html#ze-ipc-event-pool-handle-t"><span class="std std-ref">ze_ipc_event_pool_handle_t</span></a> hIpcEventPool;
receive_from_sending_process(&amp;hIpcEventPool);

// open event pool
ze_event_pool_handle_t hEventPool;
<a class="reference internal" href="api.html#zeeventpoolopenipchandle"><span class="std std-ref">zeEventPoolOpenIpcHandle</span></a>(hContext, hIpcEventPool, &amp;hEventPool);</pre>
<ol class="arabic simple" start="3">
<li><p>Each process may now refer to the same device event allocation via its handle:</p></li>
</ol>
<p>Receiving process creates event at location</p>
<pre class="literal-block">ze_event_handle_t hEvent;
<a class="reference internal" href="api.html#ze-event-desc-t"><span class="std std-ref">ze_event_desc_t</span></a> eventDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EVENT_DESC</span></a>,
    nullptr,
    5, // index
    0, // no additional memory/cache coherency required on signal
    <a class="reference internal" href="api.html#ze-event-scope-flags-t"><span class="std std-ref">ZE_EVENT_SCOPE_FLAG_HOST</span></a>, // ensure memory coherency across device and Host after event signaled
};
<a class="reference internal" href="api.html#zeeventcreate"><span class="std std-ref">zeEventCreate</span></a>(hEventPool, &amp;eventDesc, &amp;hEvent);

// submit kernel and signal event when complete
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;args, hEvent, 0, nullptr);
<a class="reference internal" href="api.html#zecommandlistclose"><span class="std std-ref">zeCommandListClose</span></a>(hCommandList);
<a class="reference internal" href="api.html#zecommandqueueexecutecommandlists"><span class="std std-ref">zeCommandQueueExecuteCommandLists</span></a>(hCommandQueue, 1, &amp;hCommandList, nullptr);</pre>
<p>Sending process creates event at same location</p>
<pre class="literal-block">ze_event_handle_t hEvent;
<a class="reference internal" href="api.html#ze-event-desc-t"><span class="std std-ref">ze_event_desc_t</span></a> eventDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EVENT_DESC</span></a>,
    nullptr,
    5,
    0, // no additional memory/cache coherency required on signal
    <a class="reference internal" href="api.html#ze-event-scope-flags-t"><span class="std std-ref">ZE_EVENT_SCOPE_FLAG_HOST</span></a>, // ensure memory coherency across device and Host after event signaled
};
<a class="reference internal" href="api.html#zeeventcreate"><span class="std std-ref">zeEventCreate</span></a>(hEventPool, &amp;eventDesc, &amp;hEvent);

<a class="reference internal" href="api.html#zeeventhostsynchronize"><span class="std std-ref">zeEventHostSynchronize</span></a>(hEvent, UINT32_MAX);</pre>
<p>Note, there is no guaranteed address equivalence for the values of <code class="docutils literal notranslate"><span class="pre">hEvent</span></code> in each process.</p>
<ol class="arabic simple" start="4">
<li><p>To cleanup, first close the pool handle in the receiving process:</p></li>
</ol>
<pre class="literal-block"><a class="reference internal" href="api.html#zeeventdestroy"><span class="std std-ref">zeEventDestroy</span></a>(hEvent);
<a class="reference internal" href="api.html#zeeventpoolcloseipchandle"><span class="std std-ref">zeEventPoolCloseIpcHandle</span></a>(&amp;hEventPool);</pre>
<ol class="arabic simple" start="5">
<li><p>Finally, return the IPC handle to the driver with <a class="reference internal" href="api.html#zeeventpoolputipchandle"><span class="std std-ref">zeEventPoolPutIpcHandle</span></a> and
free the event pool in the sending process. If <a class="reference internal" href="api.html#zeeventpoolputipchandle"><span class="std std-ref">zeEventPoolPutIpcHandle</span></a> is not called,
any actions performed by that call are eventually done by <a class="reference internal" href="api.html#zeeventpooldestroy"><span class="std std-ref">zeEventPoolDestroy</span></a>.</p></li>
</ol>
<pre class="literal-block"><a class="reference internal" href="api.html#zeeventdestroy"><span class="std std-ref">zeEventDestroy</span></a>(hEvent);
<a class="reference internal" href="api.html#zeeventpoolputipchandle"><span class="std std-ref">zeEventPoolPutIpcHandle</span></a>(hContext, hIpcEventPool);
<a class="reference internal" href="api.html#zeeventpooldestroy"><span class="std std-ref">zeEventPoolDestroy</span></a>(hEventPool);</pre>
</section>
</section>
<section id="peer-to-peer-access-and-queries">
<h3>Peer-to-Peer Access and Queries<a class="headerlink" href="#peer-to-peer-access-and-queries" title="Link to this heading">#</a></h3>
<p>Peer to Peer API’s provide capabilities to marshal data across Host to
Device, Device to Host and Device to Device. The data marshalling API
can be scheduled as asynchronous operations or can be synchronized with
kernel execution through command queues. Data coherency is maintained by
the driver without any explicit involvement from the application.</p>
<p>Cards may be linked together within a node by a scale-up fabric and depending on the configuration,
the fabric can support remote access, atomics, and data copies.</p>
<p>The following Peer-to-Peer functionalities are provided through the API:</p>
<ul>
<li><p>Check for remote memory access capability between two devices/subdevices: <a class="reference internal" href="api.html#zedevicecanaccesspeer"><span class="std std-ref">zeDeviceCanAccessPeer</span></a></p>
<blockquote>
<div><p>The following rules apply to <a class="reference internal" href="api.html#zedevicecanaccesspeer"><span class="std std-ref">zeDeviceCanAccessPeer</span></a> queries</p>
<ul class="simple">
<li><p>A device/subdevice is always its own peer, i.e. it can always access itself.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Query remote memory access, atomic capabilities, logical &amp; physical bandwidth &amp; latency for peer-to-peer: <a class="reference internal" href="api.html#zedevicegetp2pproperties"><span class="std std-ref">zeDeviceGetP2PProperties</span></a> + <a class="reference internal" href="EXT_Exp_BandwidthProperties.html#ze-experimental-bandwidth-properties"><span class="std std-ref">Bandwidth Extension Properties</span></a>.</p>
<blockquote>
<div><p>The following rules apply to <a class="reference internal" href="api.html#zedevicegetp2pproperties"><span class="std std-ref">zeDeviceGetP2PProperties</span></a> queries</p>
<ul class="simple">
<li><p>A device/subdevice is always its own peer, i.e. it can always access itself and also do so atomically.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Copy data between devices over peer-to-peer fabric: <a class="reference internal" href="api.html#zecommandlistappendmemorycopy"><span class="std std-ref">zeCommandListAppendMemoryCopy</span></a></p></li>
</ul>
<p>Both <a class="reference internal" href="api.html#zedevicecanaccesspeer"><span class="std std-ref">zeDeviceCanAccessPeer</span></a> &amp; <a class="reference internal" href="api.html#zedevicegetp2pproperties"><span class="std std-ref">zeDeviceGetP2PProperties</span></a> return the same information - do two devices support peer-to-peer access? <a class="reference internal" href="api.html#zedevicegetp2pproperties"><span class="std std-ref">zeDeviceGetP2PProperties</span></a> provides more detail than <a class="reference internal" href="api.html#zedevicecanaccesspeer"><span class="std std-ref">zeDeviceCanAccessPeer</span></a>, such as support for atomics, bandwidths, latencies, etc…</p>
</section>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="INTRO.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Introduction</p>
      </div>
    </a>
    <a class="right-next"
       href="../tools/PROG.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Tools Programming Guide</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#drivers-and-devices">Drivers and Devices</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#drivers">Drivers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#device">Device</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#initialization-and-discovery">Initialization and Discovery</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#contexts">Contexts</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#memory-and-images">Memory and Images</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#memory">Memory</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#types">Types</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#access-capabilities">Access Capabilities</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#cache-hints-prefetch-and-memory-advice">Cache Hints, Prefetch, and Memory Advice</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reserved-device-allocations">Reserved Device Allocations</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#reserving-virtual-address-space">Reserving Virtual Address Space</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#growing-virtual-address-reservations">Growing Virtual Address Reservations</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#physical-memory">Physical Memory</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mapping-virtual-memory-pages">Mapping Virtual Memory Pages</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#access-attributes">Access Attributes</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#sparse-mappings">Sparse Mappings</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#images">Images</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#device-cache-settings">Device Cache Settings</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#external-memory-import-and-export">External Memory Import and Export</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#command-queues-and-command-lists">Command Queues and Command Lists</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#command-queue-groups">Command Queue Groups</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#discovery">Discovery</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#command-queues">Command Queues</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#creation">Creation</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#execution">Execution</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#destruction">Destruction</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#command-lists">Command Lists</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#creation-1">Creation</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#appending">Appending</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#submission">Submission</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#recycling">Recycling</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#low-latency-immediate-command-lists">Low-Latency Immediate Command Lists</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#synchronization-primitives">Synchronization Primitives</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fences">Fences</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#events">Events</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#kernel-timestamp-events">Kernel Timestamp Events</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#barriers">Barriers</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#execution-barriers">Execution Barriers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#memory-barriers">Memory Barriers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#range-based-memory-barriers">Range-based Memory Barriers</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#modules-and-kernels">Modules and Kernels</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#modules">Modules</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#module-build-options">Module Build Options</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#module-specialization-constants">Module Specialization Constants</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#module-build-log">Module Build Log</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamically-linked-modules">Dynamically Linked Modules</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#module-caching-with-native-binaries">Module Caching with Native Binaries</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#built-in-kernels">Built-in Kernels</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kernels">Kernels</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#kernel-properties">Kernel Properties</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#execution-1">Execution</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#kernel-group-size">Kernel Group Size</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#kernel-arguments">Kernel Arguments</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#kernel-launch">Kernel Launch</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#cooperative-kernels">Cooperative Kernels</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sampler">Sampler</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#formatted-output">Formatted Output</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#advanced">Advanced</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#environment-variables">Environment Variables</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#device-hierarchy">Device Hierarchy</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#affinity-mask">Affinity Mask</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sub-device-support">Sub-Device Support</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#device-residency">Device Residency</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#interoperability-with-other-apis">Interoperability with Other APIs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#inter-process-communication">Inter-Process Communication</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#memory-1">Memory</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#events-1">Events</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#peer-to-peer-access-and-queries">Peer-to-Peer Access and Queries</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Intel
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024, Intel.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>